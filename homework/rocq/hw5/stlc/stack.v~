Require Export stlc.red.
Require Export stlc.small_step.
Require Export stlc.red_equiv.

Export ScopedNotations.

Export Lists.List.ListNotations.
Open Scope list_scope.

(* Frame grammar *)
Inductive frame := 

  | f_let  : Tm 1 -> frame.

Definition stack : Type := list frame.

Definition machine : Type := (stack * Tm 0).

Module Stack.

Inductive step : machine -> machine -> Prop := 

  | s_let_cong s e1 e2 : 
    step (s, let_ e1 e2) (f_let e2 :: s, e1)
  | s_letv s e2 v :
    is_value v = true ->
    step (f_let e2 :: s, v) (s, e2 [v..]).
  
End Stack.

Module Notations.
Include RedNotations.
Infix "↦"  := Stack.step (at level 70).
Infix "↦*"  := (multi Stack.step) (at level 70).
End Notations.

Export Notations.
 
Lemma bigstep_value e v : 
  e ⇓ v -> is_value v = true.
Proof. 
  intro h; induction h. all: eauto.
Qed.

Lemma bigstep_completeness e v :
  e ⇓ v -> 
  forall s : stack, (s, e) ↦* (s, v).
Proof.
  intro h.
  induction h. 
(* FILL IN HERE *) Admitted.


Corollary smallstep_completeness e v: 
  e ⟱ v -> ([], e) ↦* ([], v).
Proof.
  intros h.
  generalize ([] : stack).
  apply SmallBig.same_semantics in h.
  eapply bigstep_completeness; auto.
Qed.


(* ----------------------------- *)

Fixpoint unravel (s : stack ) (e : Tm 0 ) : Tm 0 (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Lemma stack_cong s e e' : 
  (e ~> e') -> unravel s e ~> unravel s e'.
Proof.
  move: e e'.
  induction s.
(* FILL IN HERE *) Admitted.

Lemma unravel_step {k e k' e'} :
  (k, e) ↦ (k', e') -> (unravel k e) ~>* (unravel k' e').
Proof.
  intro h.
  dependent induction h; subst.
(* FILL IN HERE *) Admitted.

Lemma unravel_multistep s s' e e': 
  (s, e) ↦* (s', e') -> unravel s e ~>* unravel s' e'.
Proof.
  intro h. dependent induction h.
  - eapply ms_refl.
  - destruct e2 as [s2 e2].
    specialize (IHh s2 s' e2 e' ltac:(eauto) ltac:(eauto)).
    eapply ms_app. eapply unravel_step; eauto.
    eauto.
Qed.
    
Lemma smallstep_soundness e v: 
  ([], e) ↦* ([], v) /\ is_value v = true -> e ⟱ v.
Proof.
  intros [h1 h2]. split; auto.
  eapply unravel_multistep in h1. eapply h1.
Qed.

Lemma stack_machine_correctness e v:
  ([], e) ↦* ([], v) /\ is_value v = true <-> e ⟱ v.
Proof.
  split. eapply smallstep_soundness. 
  intros [h1 h2]. split; auto.
  eapply smallstep_completeness; split; auto.
Qed.
