\chapter{(Untyped) program equivalence}

What does it mean for two closed programs $[[e1]]$ and $[[e2]]$ to be \emph{equivalent}?

\begin{itemize}
\item They have the same syntax.

\item They have the same syntax, up to renaming of bound variables.

\item One evaluates to the other.
  In other words, $[[ e1 ~>* e2]]$ or $[[e2 ~>* e1]]$.

\item They evaluate to the same value.
  In other words, there exists some $v$, such that 
  $[[ e1 ~>* ret v ]]$ and $[[e2 ~>* ret v]]$.

\item They evaluate to some common term (not necessarily a value).  In other
  words, there exists some $e$, such that $[[ e1 ~>* e ]]$ and $[[e2 ~>* e]]$.

\item They either both evaluate to a value or both diverge. In other words,
  $\exists [[v1]], [[ e1 ~>* ret v1 ]]$ if and only if 
  $\exists [[v2]], [[e2  ~>* ret v2]]$.

\item No closed function that returns a natural number can distinguish them.
  In other words \emph{for all} $[[ e ]]$, 
  $[[e e1 ~>* ret k]]$ iff $[[e e2 ~>* ret k]]$.

\end{itemize}

And what if the programs are open? We cannot evaluate them, so how can we
figure out whether they are equivalent?  And why does it matter whether
programs are equivalent? How can we make use of this property?

\section{Preliminaries}

In this chapter, we will examine a few different definitions of equivalence
for a call-by-value version of the \emph{untyped} lambda calculus, augumented
with numbers, recursive functions and unit.  As in the
previous chapters, we will work with a fine-grained language, and use a
stack-based operational semantics for evaluation.

\begin{definition}[\link{untyped/syntax.sig}{}{Syntax}]
\[
\begin{array}{lrcl}
\textit{values} & [[v]] & ::= & [[x]]\ |\ [[unit]]\ |\ [[fun_ f x.e]]\ |\ [[0]]\ |\ [[S v]]\ \\ % |\ [[(v1, v2)]]\ |\ [[inj1 v]] |\ [[inj2 v]] \\
\textit{terms}  & [[e]] & ::= & [[ret v]]\ |\ [[let x = e1 in e2]]\ |\ [[v1 v2]]\ |\ [[case v of { 0 => e0 ; S y => e1 } ]]\\
%       && | & [[prj1 v]]\ |\ [[prj2 v]]\ |\ [[case v of { inj1 x => e1 ; inj2 x => e2 } ]] \\
\textit{frame} & [[frame]] & ::= & [[ let x = _ in e2]] \\
\textit{stack} & [[s]]     & ::= & [[nil]]\ |\ [[frame : s]] \\
\end{array}
\]
\end{definition}

The small-step operational semantics is similar to the one found in Chapter~\ref{ch:stack}, and makes use of a stack of frames.
We define the stack semantics in terms of an underlying \link{untyped/prim.v}{primitive}{primitive reduction relation} (written $[[~>>]]$ but not shown here).

\begin{definition}[\link{untyped/stack.v}{step}{Small-step semantics}]
\drules{$[[m |-> m']]$}{$[[m]]$ small-steps to $[[m']]$ }
{ssm-prim,ssm-push,ssm-pop}
\end{definition}

We also work with the reflexive, transitive closure of this small-step
relation, written $[[m |->* m']]$, and a similar variant that tracks the number
of steps taken during evaluation.

\begin{definition}[\link{common/relations.v}{step_n}{Stepped small-step semantics}]

\drules[sn]{$[[m |-k> m']]$}{$[[m]]$ small-steps to $[[m']]$ in exactly $k$ steps}
{refl,trans}
\end{definition}

We also define predicates that talk about when a machine evaluates to a terminal 
state: i.e. an empty stack paired with a returned value.

\begin{definition}[\link{untyped/stack.v}{halts}{Halts}]
A machine halts, written $[[halts m]]$ when $[[m |->* <nil, ret v>]]$.
A machine \emph{halts in k}, written $[[halts k m]]$ when $[[m |-k> <nil, ret v>]]$.
\end{definition}

\noindent
These predicates are closed under forward and reverse evaluation.
\begin{lemma}[\link{untyped/stack.v}{halts_reverse}{Halts forward and reverse}]
Suppose $[[m |-> m']]$.
\begin{enumerate} 
\item $[[halts m]]$ implies $[[halts m']]$.
\item $[[halts m']]$ implies $[[halts m]]$.
\item $[[halts k m']]$ implies $[[halts (S k) m']]$
\item $[[halts k m]]$ implies there exists some $j$, such that $[[S j]] = k$ and $[[halts j m']]$.
\end{enumerate}
\end{lemma}

We can also say when one machine \emph{approximates} (or \emph{approximates in k}) another machine. 
\begin{definition}[Approximates]
We have $[[m1 <= m2]]$ when $[[halts m1 implies halts m2]]$ and 
$[[m1 <k= m2]]$ when $[[halts k m1 implies halts m2]]$.
\end{definition}

The approximation relation is a pre-order as it is both reflexive and transitive.
The second one is a reflexive, step-indexed relation. When we want to generalize 
over the steps, we write it as $[[m1 <=. m2]]$.

\subsection{Scopes and scoped relations}

We are not going to talk about typing for this language, but we will be
explicit about \emph{scopes}. A scope, $X$, is a set variables that are allowed to
appear free in a value or term. In the accompanying Rocq formalization, we use
a de Bruijn representation of variables, so scopes can be tracked using a
single number (an upper bound on the indices that can appear in the term).
Here we will use sets of names instead.

\begin{definition}[Well-scoped]
A term/value is \emph{well scoped}, written $[[ X |- e ]]$ (or $[[ X |- v
]]$), when its free variables are a subset of $[[X]]$.
\end{definition}

\begin{definition}[Closed]
A term/value is \emph{closed}, written $[[ null |- e ]]$ (or $[[ null |- v ]]$), when it
is well-scoped with an empty set of variables. (We use $[[null]]$ to
indicate the empty set.)
\end{definition}

\begin{definition}[\link{untyped/ctx.v}{scoped_relation}{Scoped binary relation}]
A scoped binary relation is a relation between two terms or values with the
same scope. We use the metavariables $[[RE]]$ and $[[RV]]$ for arbitrary scoped 
relations on terms and values and assert that terms and values are in these relations uing the judgment forms 
$[[X |- e RE e']]$ and $[[X |- v RV v']]$.
\end{definition}

\begin{definition}[Closing substitution]
A substitution $[[sigma]]$ is a \emph{closing} substitution, written 
$[[ X |- sigma]]$, when it maps all variables in $[[X]]$ to closed values. In other words, 
we have $[[ null |- sigma x ]]$ for all $[[x]] \in [[X]]$.
\end{definition}

\begin{definition}[\link{equiv/ctx.v}{PreOrder}{Scoped pre-order}]
A scoped relation is a \emph{scoped pre-order} when it is reflexive and
transitive.
\end{definition}

\begin{definition}[Scoped equivalence]
A scoped relation is a \emph{scoped equivalence} when it is reflexive, transitive and
symmetric.
\end{definition}

We can trivially turn any preorder into an equivalence by relating terms in
both directions. Therefore, we are going to mainly work with preorders going
forward. This is both easier (as we don't have to show both directions) and
sometimes more informative (as there are terms that will only be related in
one direction).

\subsection{Observations on terms}

Let's look at our first preorder, which only talks about closed terms. This
relation orders expressions by their termination behavior when evaluated by
arbitrary stacks. The relation is a pre-order---it is not to difficult to show
that it is both reflexive and transitive.

\begin{definition}[\link{untyped/equiv.v}{CIU}{Usage Preorder}]
We say that $[[e <= e']]$ when
$[[halts <s,e>]]$ implies $[[halts <s,e'>]]$, for all stacks $[[s]]$. 
In other words, we have $[[<s,e> <= <s,e'>]]$ for all stacks $[[s]]$.
\end{definition}

Remember that we can extend this to an equivalence.

\begin{definition}[Usage Equivalence]
We say that $[[e]] \equiv_{U} [[e']]$ when $[[e <= e']]$ and $[[e' <= e]]$.
\end{definition}

We call this idea of running the program using arbitrary stacks as making
\emph{observations} on the terms. This fact that we quantify over all stacks
is important because just because both terms co-terminate does not mean that
they should be equivalent.  One could program could terminate with 3 and the
other terminate with 5. However, one way to observe the difference between
these terms is to run these two programs on a stack that diverges when its
argument is greater than 4. If there is no way to tell them apart then we call
them equivalent.

Because we are working with an untyped language, some evaluations will get
stuck. However, the definition of $\ottkw{halts}$ requires the abstract
machine to evaluate completely to a terminal configuration. As a result,
programs that always get stuck will be equal to eachother (and to programs
that always diverge).

If we were working with a language where all programs terminate, then we would
define observations differently. We would instead choose an observation type,
like bool or nat, and require that both terms produce the same value of this
type.  It is important that syntactic equivalence is sufficient. We can't use
functions as our observation type because we sometimes want to identify
functions that are not syntactically equal, like $[[\x. x + 0]]$ and
$[[\x.x]]$. However, limiting observations to booleans or natural numbers is
not a problem. When we quantify over all stacks, we can relate expressions
that return any type of value.

Usage equivalence is sometimes called an \emph{extensional} equivalence
because it is based on what the program does (how it interacts with the
external environment) instead of how the program is implemented (its internal
definitions).

\section{Scoped preorders and equivalences}

\subsection{CIU pre-order $[[CIU]]$}

Next, we use closing substitutions to extend our usage preorder/equivalence to 
include upen terms.

\begin{definition}[\link{untyped/equiv.v}{CIU}{CIU Preorder}]
We say that $[[ X |- e CIU e' ]]$ when for all stacks $[[s]]$, and for all 
closing substitutions $[[X |- sigma]]$, 
$[[halts <s,e[sigma]>]]$ implies $[[halts <s,e'[sigma]>]]$.
In other words, $[[<s,e[sigma]> <= <s,e'[sigma]>]]$.
\end{definition}

Furthermore, if this relation holds in both directions, then we get an
equivalence relation, which we call \emph{observational equivalence} or
\emph{CIU} equivalence.

\begin{definition}[Observational equivalence]
Two terms are \emph{observationally equivalent} when $[[ X |- e CIU e' ]]$
and $[[ X |- e' CIU e]]$.
\end{definition}

The letters $[[CIU]]$ in the name of this relation come from \emph{uses of
closed instantiations}~\cite{Mason_Talcott_1991}, i.e. we create closed
instantiations with arbitrary substitutions, and use them with arbitrary
stacks. 

\subsection{Contextual pre-order and equivalence ($[[CON]]$)}

A program context is any part of a term or value that can surround a term or
value. We use the metavariable $[[C]]$ to refer to contexts that produce terms
and contexts that produce values.

\begin{definition}[\link{equiv/contextual.v}{Context}{Program Context}]
\[
\begin{array}{lcl}
[[C]] &::= & [[#]]\ |\ [[C v2]]\ |\ [[v1 C]]\ |\ [[let x = C in e2]]\ |\ [[let x = e1 in C]] \\
      & |   & [[ret C]]\ |\ [[case v of { 0 => C ; S y => e1 }]]\ |\ [[ case v of { 0 => e0 ; S y => C }]] \\
\\
[[C]] &::= & [[#]]\ |\ [[succ C]]\ |\  [[fun_ x y . C ]] \\
\end{array}
\]
\end{definition}

We use the notation $[[C{|e|}]]$ and $[[C{|v|}]]$ for plugging the hole in a
context with a value or term.

Here's another way to define an equality on terms. Instead of using stacks and
closing substitutions, we can quantify over contexts. (This definition is
typically used when we don't have a stack-based semantics handy.)

\begin{definition}[Contextual pre-order]
Define $[[X |- e1 CON e2 ]]$ when 
$[[halts C {| e1 |} ]]$ implies $[[halts C {| e2 |} ]]$ for any $[[ C]]$.
\end{definition}

\subsection{Contextual Equivalence (Pitts) ($[[CTX]]$)}

Yet another way to define when two terms are related is \emph{coinductively}. We
will define a \emph{contextual pre-order} as the largest pre-order that is 
adequate and compatible. This terminology overlaps with the definition in the previous 
section. While a little confusing, we will soon see that they are the same relation.

Adequacy describes a minimal requirement on relations. If they say that two
closed terms are equal, then both terms must halt when evaluated.  While this
seems too weak to be a basis of an equivalence, in conjunction with the other
properties, we will see that it is enough.

\begin{definition}[\link{untyped/equiv.v}{Adequate}{Adequate}]
A scoped relation $[[RE]]$ is \emph{adequate} when $[[ null |- e RE e']]$ means that 
$[[ halts < nil, e > ]]$ implies $[[ halts < nil, e' >]]$.
In other words, $[[ <nil,e> <= <nil, e'> ]]$.
\end{definition}

Compatibility means that terms are related when their subterms are
related. Because our syntax is mutually defined by terms and values, we
actually need compatibility to hold for a pair of relations.

\begin{definition}[\link{untyped/equiv.v}{Compatible}{Compatible}]
A pair of scoped relations $[[RE]]$ and $[[RV]]$ are compatible when the following properties hold: 
\begin{enumerate}
\item $[[X |- x RV x]]$
\item $[[X |- unit RV unit ]]$
\item $[[X |- zero RV zero ]]$
\item $[[X |- v1 RV v2 ]]$ implies $[[X |- succ v1 RV succ v2]]$
\item $[[X, x |- e1 RE e2 ]]$ implies $[[ X |- \x.e1 RV \x.e2]]$
\item $[[X |- v1 RV v2 ]]$ implies $[[X |- ret v1 RE ret v2 ]]$
\item $[[X |- e1 RE e2 ]]$ and $[[X , x |- e1' RE e2' ]]$
  implies $[[X |- let x = e1 in e1' RE let x = e2 in e2' ]]$
\item $[[X |- v1 RV v2 ]]$ and $[[X |- v1' RV v2']]$ implies
  $[[X |- v1 v1' RE v2 v2' ]]$.
\item $[[X |- v1 RV v2 ]]$ and $[[X |- e1 RE e2]]$  and $[[ X, x |- e1' RE e2']]$
  implies $[[X |- case v1 of { 0 => e1 ; S x => e1' }  RE case v1' of { 0 => e1' ; S x => e2' } ]]$
\end{enumerate}
\end{definition}

If we have more syntactic forms in our language, we need to add more
clauses to this definition. The property that we want to hold is that 
we have one clause for each syntactic form, so that we can guarantee that 
the relation is reflexive.

\begin{lemma}[\link{untyped/equiv.v}{Compatible_refl}{Compatible relations are reflexive}]
If we have $[[Compatible RE RV]]$, then both $[[RE]]$ and $[[RV]]$ are reflexive.
\end{lemma}

Now, here is our key definition: 

\begin{definition}[\link{untyped/equiv.v}{CTX}{Contextual preorder}]
Define $[[X |- e CTX e']]$ if there is some compatible, adequate pre-order $[[RE]]$, such 
that $[[X |- e RE e']]$.
\end{definition}

As above, we define contextual equivalence when this preorder holds in both
directions, i.e. $[[X |- e CTX e']]$ and $[[X |- e' CTX e]]$.

What this means is that to show two terms are equivalent, we just need to find
any relation that equates them, as long as that relation has the right
properties. That is a useful definition because it gives us a practical way to
show that terms are contextually equivalent.

\subsection{A logical relation $[[log]]$}

Finally, we can define a \emph{step-indexed} logical relation.

\begin{definition}[\link{untyped/equiv.v}{C}{Step-indexed Logical Relation}]
\[ 
\begin{array}{lclcl} 
   [[C e1 e2 k]] 
      & = & \forall [[s1]], [[s2]], [[St s1 s2 ===>k <s1,e1> <=. <s2,e2> ]] \\
\\
   [[St s1 s2 k]] &=& \forall [[v1]], [[v2]], 
       [[V v1 v2 ===>k <s1,ret v1> <=. <s2,ret v2> ]] \\
\\
   [[V unit unit k]]             &=& \textit{always} \\
   [[V zero zero k]]             &=& \textit{always} \\
   [[V (succ v1) (succ v2) k]]   &=& [[|> k V v1 v2]] \\
   [[V (fun_ x y.e) v2 k]]        &=& \forall [[v]][[v']], 
   [[V v v' ===>k C e[(fun_ x y. e)/y, v1/x] (v2 v') ]] \\
\end{array}
\]                 
\end{definition}

Because stacks are closed, we can immediately relate them by quantifying 
over all steps. 
\begin{definition}[Stack relation]
$[[ |- s1 log s2 ]]$ when 
  $[[ St s1 s2 k]]$, for all $[[k]]$.
\end{definition}

This relation extends to a step-indexed relation on closing substitutions.
\begin{definition}[Related closing substitutions]
 $[[ X |- sigma1 log sigma2 @ k ]]$ 
when $[[ V (sigma1 x) (sigma2 x) k ]]$
\end{definition}

Which we can use to create scoped preorders on values, terms and stacks.
\begin{definition}[Related values, terms and stacks]\ \\
\begin{enumerate}
\item
$[[ X |- v1 log v2 ]]$ when 
  $[[ X |- sigma1 log sigma2 @ k ]]$ 
  implies $[[ V v1[sigma1] v2[sigma2] k]]$
  for all $[[k]]$.
\item
$[[ X |- e1 log e2 ]]$ when 
  $[[ X |- sigma1 log sigma2 @ k ]]$ implies 
  $[[ C e1[sigma1] e2[sigma2] k]]$, 
  for all $[[k]]$
\item
\end{enumerate}
\end{definition}

\section{Examples}
The amazing result is that all of these definitions coincide. All of the pre-orders (and induced equivalence relations) from the previous section relate the same terms.

But why do we have so many definitions? How can we use them?

Pitt's definition of contextual equivalence reassures us that, from our
starting definitions of what it means for programs to approximate one another,
we have the coarsest definition possible. There isn't some other definition of
equivalence out there that would relate more terms. Furthermore, if we find 
any preorder that is compatible and adequate, that relates two terms, then 
we know that they are in the contextual preorder.

The traditional definition of Contextual equivalence justifies the refactoring
that programmers do, or that compilers do when they optimize code. It says
that you can start with any program identify some subterm anywhere and replace
it with something equivalent without changing the semantics of the program.

The CIU pre-order is the most convenient definition for reasoning about
reduction. For example, we can use this definition to show that inlining or
``beta-reduction'' is a sound program transformation.
\begin{lemma}[\link{untyped/equiv_examples.v}{fun_beta}{Beta reduction and expansion}]
\begin{enumerate}
\item $[[ X |- (fun_ x y.e) v CIU v [v/y, fun_ x y. e/x] ]]$
\item $[[ X |- v [v/y, fun_ x y. e/x] CIU (fun_ x y.e) v ]]$
\end{enumerate}
\end{lemma}

From these (and other) facts, we can show that the usual definition of untyped
$\beta$-equivalence implies contextual equivalence. However,
$\beta$-equivalence is not as large as contextual equivalence: there are terms
that are not $\beta$-equivalent that are not contextually equivalent.

Finally, the logical relation is the most convenient for showing the soundness
of ``$\eta$-reductions''. 

\begin{lemma}[\link{untyped/equiv_examples.v}{fun_eta}{Function $\eta$-reduction}]
$[[ X |- fun_ x y. v y log v ]]$
\end{lemma}

\begin{lemma}[\link{untyped/equiv_examples.v}{nat_eta}{Nat $\eta$-reduction}]
$[[ X |- case v of { 0 => 0; S x => S x } log v ]]$
\end{lemma}

On the other hand, using our definitions, \emph{$\eta$-expansions} are not validated by our 
definitions. We can use the tradutional definition of contextual equivalence to show that 

\begin{lemma}[Failure of $\eta$-expansion]
It is not the case that $[[ X |- v CON fun_ x y. v y ]]$ for all $[[v]]$.
\end{lemma}
Choose $[[v]]$ as zero and the context as $[[ # zero ]]$.

\section{Relating the relations}

Finally, let's prove that these relations are equivalent.

\begin{theorem}[\link{untyped/contextual.v}{CTX_Contextual}{$[[CON]]$ is the same as $[[CTX]]$}]
We have $[[X |- e CON e']]$ iff $[[X |- e CTX e']]$.
\end{theorem}

\begin{theorem}[\link{untyped/equiv.v}{CTX_CIU}{$[[CTX]]$ is the same as $[[CIU]]$}]
We have $[[X |- e CIU e']]$ iff $[[X |- e log e']]$ iff $[[X |- e CTX e']]$.
\end{theorem}

We don't do this all at once: it takes several steps to make all of these definitions line up.

\begin{enumerate}
\item Show that $[[CON]]$ is adequate and compatible (so $[[CON]]$ implies $[[CTX]]$).
\item Show that $[[log]]$ is adequate and compatible (and therefore reflexive).
\item Show that $[[log]]$ implies $[[CIU]]$. This follows from the reflexivity of the logical relation.
\item Show that $[[CIU]]$ implies $[[log]]$. This follows from the reflexivity of the logical relation, and the fact that it is closed under CIU-equivalence (see lemma~\ref{lem:eqtm_closed_CIU}).
\item Show that $[[CIU]]$ implies $[[CTX]]$. This requires 
  showing that it is adequate and transitive (easy). To show that it is compatible, we use the fact that it is equivalent to a compatible relation ($[[log]]$).
\item Show that $[[CTX]]$ implies $[[CIU]]$. This happens in two steps. We first show this result for closed terms, by induction over the arbitrary stack. Then, we extend the proof to open terms 
by showing that contextual equivalence is closed under substitution
\item Show that $[[CTX]]$ implies $[[C]]$, using the adequacy of $[[CTX]]$, the fact that 
  contexts preserve compatible relations, and the compatibility of $[[CTX]]$.
\end{enumerate}

\subsection{$[[CON]]$ is adequate and compatible}

To reason about contextual equivalence, we need to be able to compose contexts, written $[[C1 o C2]]$
and reason about how that composition interacts with plugging terms.

\begin{lemma}[\link{untyped/contextual.v}{compose_plug}{Compose plug}]
 C2 {| C1 {| e |} |} = (C1 o C2) {| e |}
\end{lemma}

Showing that contextual equivalence is adequate is easy. We merely need to use the context that is a single hole, and the definition falls out. 

For compatibility, we need to instantiate premises with the appropriate contexts. For example, so 
show that contextual equivalence is compatible for application expressions, we prove the following 
sublemma.

\begin{lemma}[App Compatibility]
If $[[X |- v1 CON v2 ]]$ and $[[ X |- v1' CON v2' ]]$ then $[[X |- v1 v1' CON v2 v2']]$.
\end{lemma}
\begin{proof}
To show $[[X |- v1 v1' CON v2 v2']]$, we pick an arbitrary context $[[C]]$, and show that 
$[[ C {| v1 v1' |} <= C {| v2 v2' |} ]] $. We instantiate our first assumption
with the context $[[v2 # o C]]$ to conclude that $[[  C{| v2 v1' |} <= C{| v2 v2' |} ]]$.
Then, we instantiate the second assumption with $[[ # v1 o C]]$ to conclude that 
$[[ C{| v1 v1' |} <= C {| v2 v1' |} ]]$. Chaining these approximations together 
transitively gives us the desired result.
\end{proof}

\subsection{$[[log]]$ is compatible}

Because we have defined the logical relation as a step-indexed relation, we
need to first show that it is downward closed. This is not difficult to do.

\begin{lemma}[\link{untyped/equiv.v}{compat_eq}{Logical equivalence is compatible}]
We have the compatibility properties for both the computation and value logical relations.
\end{lemma}
Showing that the logical relation is compatible is very similar to proving the fundamental theorem 
for the logical relation. We want to show that the logical relation is preserved by all syntactic forms in the language. (In general, the fundamental theorem for binary logical relations shows that the relation is reflexive.)

\subsection{$[[log]]$ implies $[[CIU]]$}

\begin{lemma}[\link{untyped/equiv.v}{logtm_CIU}{$[[log]]$ implies $[[CIU]]$}]
If $[[ X |- e log e' ]]$ then $[[ X |- e CIU e' ]]$.
\end{lemma}
\begin{proof}
To show that $[[e]]$ is CIU-related to $[[e']]$, we need to pick an arbitrary stack $[[s]]$ and 
arbitrary substitution $[[sigma]]$, and show that $[[ < s,e[sigma] > <= < s, e'[sigma] > ]]$.
Now, suppose $[[< s,e[sigma] > |-k> < nil, ret v > ]]$. 
From our reflexivity property, we know that $[[ null |- sigma log sigma ]]$ and $[[ |- s log s]]$. 
Therefore, we know that $[[C e[sigma] e'[sigma] k]]$, and thus,
$[[< s, e[sigma]> <k= < s, e'[sigma] > ]]$.
\end{proof}

\subsection{$[[CIU]]$ implies $[[log]]$}

This follows from the reflexivity of the logical relation, and the fact that it is closed under CIU-equivalence (see lemma~\ref{lem:eqtm_closed_CIU}).

\begin{lemma}[\link{untyped/equiv.v}{eqtm_closed_CIU}{$[[log]]$ is closed under $[[CIU]]$}]
\label{lem:eqtm_closed_CIU}
If $[[ X |- e log e']]$ and $[[ X |- e' CIU e'' ]]$, then $[[ X |- e log e'']]$.
\end{lemma}

At this point we know that the logical and and CIU preorders coincide.

\subsection{$[[CIU]]$ implies $[[CTX]]$}
This requires showing that it is adequate and transitive (this part is easy). To show that
it is compatible, we use the fact that it is equivalent to a compatible
relation ($[[log]]$). 

\subsection{$[[CTX]]$ implies $[[CIU]]$}

This happens in two steps. We first show this result for closed terms. Then,
we extend the proof to open terms by showing that contextual equivalence is
closed under substitution.

\begin{lemma}[\link{untyped/equiv.v}{CTX_ciu}[Closed $[[CTX]]$ implies CIU]
$[[ null |- e CTX e' ]]$ implies $[[ <s,e> <= <s,e'> ]]$ for any $s$.
\end{lemma}
We prove this by induction on the stack. For $[[let x=_ in e]]$ frames, we use the
compatibility of contextual equivalence for let expressions and the
fact that approximation is closed under forwards and reverse reduction.

\begin{lemma}[\link{untyped/equiv.v}{value_substitutivity}[Substitutivity]
If $[[ X |- e CTX e' ]]$ and $[[ X |- sigma ]]$ then $[[ null |- e[sigma] CTX e'[sigma] ]]$.
\end{lemma}
We prove this by induction on the length of $[[X]]$ (i.e. the number of variables in the 
domain of $[[sigma]]$. We can show the substitivity result for single substiutions by 
using the transitivity of $[[CTX]]$ to merge the following results 

$ [[ X |- e [v/x] CTX let x = ret v in e ]]$ (by connection with $[[CIU]]$)
$ [[ X |- let x = ret v in e CTX let x = ret v in e' ]]$ (by compatibility of any underlying relation in $[[CTX]]$)
$ [[ X |- let x = ret v in e' CTX e' [v/x] ]]$ (by connection with $[[CIU]]$).


\subsection{Show that $[[CTX]]$ implies $[[CON]]$}.

For this result, we use the adequacy of $[[CTX]]$, the fact that contexts
preserve compatible relations, and the compatibility of $[[CTX]]$. We can easily get the last part now
because we have shown it equivalent to a compatible relation.

\section{Further Reading}
This chapter is inspired by Pitts\cite{pitts:DagSemProc.10351.6}. Similar
material is available in PFPL chapter 47~\cite{harper:pfpl}, although that is for a typed
language, not the untyped lambda calculus. Furthermore, similar mechanized results for CBPV 
are available in Forster et al.~\cite{forster:cbpv}.
