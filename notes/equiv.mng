\chapter{(Untyped) program equivalence}

What does it mean for two closed programs $[[e1]]$ and $[[e2]]$ to be \emph{equivalent}?

\begin{itemize}
\item They have the same syntax.

\item They have the same syntax, up to renaming of bound variables.

\item One evaluates to the other.
  In other words, $[[ e1 ~>* e2]]$ or $[[e2 ~>* e1]]$.

\item They evaluate to the same value.
  In other words, there exists some $v$, such that 
  $[[ e1 ~>* ret v ]]$ and $[[e2 ~>* ret v]]$.

\item They evaluate to some common term (not necessarily a value).  In other
  words, there exists some $e$, such that $[[ e1 ~>* e ]]$ and $[[e2 ~>* e]]$.

\item They either both evaluate to a value or both diverge. In other words,
  $\exists [[v1]], [[ e1 ~>* ret v1 ]]$ if and only if 
  $\exists [[v2]], [[e2  ~>* ret v2]]$.

\item No closed function that returns a natural number can distinguish them.
  In other words \emph{for all} $[[ e ]]$, 
  $[[e e1 ~>* ret k]]$ iff $[[e e2 ~>* ret k]]$.

\end{itemize}

And what if the programs are open? We cannot evaluate them, so how can we
figure out whether they are equivalent?  And why does it matter whether
programs are equivalent? How can we make use of this property?

\section{Preliminaries}

In this chapter, we will examine a few different definitions of equivalence
for a call-by-value version of the \emph{untyped} lambda calculus, augmented
with numbers, recursive functions and unit.  As in the
previous chapters, we will work with a fine-grained language, and use a
stack-based operational semantics for evaluation.

\begin{definition}[\link{untyped/syntax.sig}{}{Syntax}]
\[
\begin{array}{lrcl}
\textit{values} & [[v]] & ::= & [[x]]\ |\ [[unit]]\ |\ [[fun_ f x.e]]\ |\ [[0]]\ |\ [[S v]]\ \\ % |\ [[(v1, v2)]]\ |\ [[inj1 v]] |\ [[inj2 v]] \\
\textit{terms}  & [[e]] & ::= & [[ret v]]\ |\ [[let x = e1 in e2]]\ |\ [[v1 v2]]\ |\ [[case v of { 0 => e0 ; S y => e1 } ]]\\
%       && | & [[prj1 v]]\ |\ [[prj2 v]]\ |\ [[case v of { inj1 x => e1 ; inj2 x => e2 } ]] \\
\textit{frame} & [[frame]] & ::= & [[ let x = _ in e2]] \\
\textit{stack} & [[s]]     & ::= & [[nil]]\ |\ [[frame : s]] \\
\end{array}
\]
\end{definition}

The small-step operational semantics is similar to the one found in Chapter~\ref{ch:stack}, and makes use of a stack of frames.
We define the stack semantics in terms of an underlying \link{untyped/prim.v}{primitive}{primitive reduction relation} (written $[[~>>]]$ but not shown here).

\begin{definition}[\link{untyped/stack.v}{step}{Small-step semantics}]\ \\
\drules{$[[m |-> m']]$}{$[[m]]$ small-steps to $[[m']]$ }
{ssm-prim,ssm-push,ssm-pop}
\end{definition}

We also work with the reflexive, transitive closure of this small-step
relation, written $[[m |->* m']]$, and a similar variant that tracks the number
of steps taken during evaluation.

\begin{definition}[\link{common/relations.v}{step_n}{Stepped small-step semantics}]\ \\ 

\drules[sn]{$[[m |-k> m']]$}{$[[m]]$ small-steps to $[[m']]$ in exactly $k$ steps}
{refl,trans}
\end{definition}

We also define predicates that talk about when a machine evaluates to a terminal 
state: i.e. an empty stack paired with a returned value.

\begin{definition}[\link{untyped/stack.v}{halts}{Halts}]\ \\
A machine \emph{halts}, written $[[halts m]]$, when $[[m |->* <nil, ret v>]]$.
A machine \emph{halts in k}, written $[[halts k m]]$, when $[[m |-k> <nil, ret v>]]$.
\end{definition}

\noindent
These predicates are closed under forward and reverse evaluation.
\begin{lemma}[\link{untyped/stack.v}{halts_reverse}{Halts forward and reverse}]
Suppose $[[m |-> m']]$.
\begin{enumerate} 
\item $[[halts m]]$ implies $[[halts m']]$.
\item $[[halts m']]$ implies $[[halts m]]$.
\item $[[halts k m']]$ implies $[[halts (S k) m']]$
\item $[[halts k m]]$ implies $[[halts j m']]$ for some $j$, such that $[[S j]] = k$.
\end{enumerate}
\end{lemma}

We can also say when one machine \emph{approximates} (or \emph{approximates in k}) another machine. 
\begin{definition}[Machine approximation] \ \\
We have $[[m1 <= m2]]$ when $[[halts m1 implies halts m2]]$ and 
$[[m1 <k= m2]]$ when $[[halts k m1 implies halts m2]]$.
\end{definition}

The approximation relation $[[m1 <= m2]]$ is a pre-order as it is both
reflexive and transitive.  The stepped approximation $[[m1 <k= m2]]$ is a
reflexive, step-indexed relation. (It is not transitive because $[[m2]]$ may
halt in using any number of steps.) When we want to generalize over steps, we
write it as $[[m1 <=. m2]]$.

Finally, we can overload notation to say when a term approximates another by 
putting it on the empty stack.
\begin{definition}[Term approximation] \ \\
We have $[[e1 <= e2]]$ when $[[ <nil, e1> <= <nil, e2> ]]$.
\end{definition}

\subsection{Scopes and scoped relations}

We are not going to talk about typing for this language, but we will be
explicit about \emph{scopes}. A scope, $X$, is a set variables that are allowed to
appear free in a value or term. In the accompanying Rocq formalization, we use
a de Bruijn representation of variables, so scopes can be tracked using a
single number (an upper bound on the indices that can appear in the term).
Here we will use sets of names instead.

\begin{definition}[Well-scoped]
A term/value is \emph{well scoped}, written $[[ X |- e ]]$ (or $[[ X |- v
]]$), when its free variables are a subset of $[[X]]$.
\end{definition}

\begin{definition}[Closed]
A term/value is \emph{closed}, written $[[ null |- e ]]$ (or $[[ null |- v ]]$), when it
is well-scoped with an empty set of variables. (We use $[[null]]$ to
indicate the empty set.)
\end{definition}

\begin{definition}[\link{untyped/ctx.v}{scoped_relation}{Scoped binary relation}]
A scoped binary relation is a relation between two terms or values with the
same scope. We use the metavariables $[[RE]]$ and $[[RV]]$ for arbitrary scoped 
relations on terms and values and assert that terms and values are in these relations using the judgment forms 
$[[X |- e RE e']]$ and $[[X |- v RV v']]$.
\end{definition}

\begin{definition}[Closing substitution]
A substitution $[[sigma]]$ is a \emph{closing} substitution, written 
$[[ X |- sigma]]$, when it maps all variables in $[[X]]$ to closed values. In other words, 
we have $[[ null |- sigma x ]]$ for all $[[x]] \in [[X]]$.
\end{definition}

\begin{definition}[\link{equiv/ctx.v}{PreOrder}{Scoped pre-order}]
A scoped relation is a \emph{scoped pre-order} when it is reflexive and
transitive.
\end{definition}

\begin{definition}[Scoped equivalence]
A scoped relation is a \emph{scoped equivalence} when it is reflexive, transitive and
symmetric.
\end{definition}

We can trivially turn any preorder into an equivalence by relating terms in
both directions. Therefore, we are going to mainly work with preorders going
forward. This is both easier (as we don't have to show both directions) and
sometimes more informative (as there are terms that will only be related in
one direction).

\section{Scoped preorders and equivalences}

\subsection{CIU pre-order $[[CIU]]$}

Let's look at our first preorder. This relation orders expressions by their
termination behavior when evaluated by arbitrary stacks, under arbitrary
substitutions.

\begin{definition}[\link{untyped/equiv.v}{CIU}{CIU Preorder}]
We say that $[[ X |- e CIU e' ]]$ when for all stacks $[[s]]$, and for all 
closing substitutions $[[X |- sigma]]$, 
$[[halts <s,e[sigma]>]]$ implies $[[halts <s,e'[sigma]>]]$.
In other words, when $[[<s,e[sigma]> <= <s,e'[sigma]>]]$.
\end{definition}

This relation is trivially a preorder because it is defined in terms of the 
approximation preorder.

Furthermore, if this relation holds in both directions, then we get an
equivalence relation, which we call \emph{observational equivalence} or
\emph{CIU} equivalence.

\begin{definition}[Observational equivalence]
Two terms are \emph{observationally equivalent} when $[[ X |- e CIU e' ]]$
and $[[ X |- e' CIU e]]$.
\end{definition}

We call this idea of running the program using arbitrary stacks as making
\emph{observations} on the terms. This fact that we quantify over all stacks
is important. Just because two terms co-terminate does not mean that they are
equivalent.  One program could terminate with 3 and the other terminate
with 5. However, one way to observe the difference between these terms is to
run these two programs on a stack that diverges when its argument is greater
than 4. If there is no way to tell them apart then we call them equivalent.

Because we are working with an untyped language, some evaluations will get
stuck. However, the definition of $\ottkw{halts}$ requires the abstract
machine to evaluate completely to a terminal configuration. As a result,
programs that always get stuck will be equal to each other (and to programs
that always diverge).

If we were working with a language where all programs terminate, then we would
define observations differently. We would instead choose an observation type,
like bool or nat, and require that both terms produce the same value of this
type.  It is important that syntactic equivalence is sufficient. We can't use
functions as our observation type because we sometimes want to identify
functions that are not syntactically equal, like $[[\x. x + 0]]$ and
$[[\x.x]]$. However, limiting observations to booleans or natural numbers is
not a problem. When we quantify over all stacks, we can relate expressions
that return any type of value.

Usage equivalence is sometimes called an \emph{extensional} equivalence
because it is based on what the program does (how it interacts with the
external environment) instead of how the program is implemented (its internal
definitions).

The letters $[[CIU]]$ in the name of this relation come from \emph{uses of
closed instantiations}~\cite{Mason_Talcott_1991}, i.e. we create closed
instantiations with arbitrary substitutions, and use them with arbitrary
stacks. 

\subsection{Contextual pre-order and equivalence ($[[CON]]$)}

A program context is any part of a term or value that can surrounds a single
hole, written $[[#]]$. We use the metavariable $[[C]]$ to refer to contexts,
formed by the following grammar:

\begin{definition}[\link{equiv/contextual.v}{Context}{Program Context}]
\[
\begin{array}{lcl}
[[C]] &::= & [[#]]\ |\ [[C v2]]\ |\ [[v1 C]]\ |\ [[let x = C in e2]]\ |\ [[let x = e1 in C]] \\
      & |  & [[ret C]]\ |\ [[case v of { 0 => C ; S y => e1 }]]\ |\ [[ case v of { 0 => e0 ; S y => C }]] \\
      & |  & [[succ C]]\ |\  [[fun_ x y . C ]]\ |\ [[case C of { 0 => e0 ; S y => e1 }]]\  \\
\end{array}
\]
\end{definition}

We use the notation $[[C{|e|}]]$ and $[[C{|v|}]]$ for plugging the hole in a
context with a term or value. This notation has the implicit constraint that
the hole is in a term position for the first operation and a value position
for the second operation. For example, we can only plug a value into the 
context $[[# zero]]$, and we can only plug an expression into the context 
$[[ fun_ x y. # ]]$.

We use contexts to define the \emph{contextual} pre-order on terms and
values. Instead of using stacks and closing substitutions, we instead quantify
over arbitrary contexts. 

\begin{definition}[Contextual pre-order (terms)]
Define $[[X |- e1 CON e2 ]]$ when 
we have $[[C {| e1 |} <= C {| e2 |} ]]$ for any $[[C]]$.
\end{definition}
\begin{definition}[Contextual pre-order (values)]
Define $[[X |- v1 CON v2 ]]$ when 
$[[ C {| v1 |} <= C {| v2 |} ]]$ for any $[[C]]$.
\end{definition}

As above, we can turn this definition into an equivalence by requiring it it
both directions.

This definition is the one most commonly referred to by the name ``contextual
equivalence''.  And it indeed is the most flexible to use. If we know that two
terms are equivalent then we can replace any one term with another in any
context without changing the termination behavior of the program.

Furthermore, we will also be able to show that programs with contextually
equivalent parts are contextually equivalent.

\begin{lemma}[Contextual replacement]
If $[[X |- e1 CON e2 ]]$ then $[[ null |- C{|e1|} CON C{|e2|} ]]$.
\end{lemma}

\subsection{Contextual Equivalence (Pitts) ($[[CTX]]$)}

Yet another way to define when two terms are related is \emph{coinductively}. We
will define a \emph{contextual pre-order} as the largest pre-order that is 
adequate and compatible. This terminology overlaps with the definition in the previous 
section. While a little confusing, we will soon see that they are the same relation.

Adequacy describes a minimal requirement on relations. If they say that two
closed terms are equal, then both terms must halt when evaluated.  While this
seems too weak to be a basis of an equivalence, in conjunction with the other
properties, we will see that it is enough.

\begin{definition}[\link{untyped/equiv.v}{Adequate}{Adequate}]
A scoped relation $[[RE]]$ is \emph{adequate} when $[[ null |- e RE e']]$ means that 
$[[ halts < nil, e > ]]$ implies $[[ halts < nil, e' >]]$.
In other words, $[[ <nil,e> <= <nil, e'> ]]$.
\end{definition}

Compatibility means that terms are related when their subterms are
related. Because our syntax is mutually defined by terms and values, we
actually need compatibility to hold for a pair of relations.

\begin{definition}[\link{untyped/equiv.v}{Compatible}{Compatible}]
\label{def:compatible}
A pair of scoped relations $[[RE]]$ and $[[RV]]$ are \emph{compatible} when the following properties hold: 
\begin{enumerate}
\item $[[X |- x RV x]]$
\item $[[X |- unit RV unit ]]$
\item $[[X |- zero RV zero ]]$
\item $[[X |- v1 RV v2 ]]$ implies $[[X |- succ v1 RV succ v2]]$
\item $[[X, x,y |- e1 RE e2 ]]$ implies $[[ X |- fun_ x y.e1 RV fun_ x y.e2]]$
\item $[[X |- v1 RV v2 ]]$ implies $[[X |- ret v1 RE ret v2 ]]$
\item $[[X |- e1 RE e2 ]]$ and $[[X , x |- e1' RE e2' ]]$
  implies $[[X |- let x = e1 in e1' RE let x = e2 in e2' ]]$
\item $[[X |- v1 RV v2 ]]$ and $[[X |- v1' RV v2']]$ implies
  $[[X |- v1 v1' RE v2 v2' ]]$.
\item $[[X |- v1 RV v2 ]]$ and $[[X |- e1 RE e2]]$  and $[[ X, x |- e1' RE e2']]$
  implies $[[X |- case v1 of { 0 => e1 ; S x => e1' }  RE case v1' of { 0 => e1' ; S x => e2' } ]]$
\end{enumerate}
\end{definition}

If we have more syntactic forms in our language, we need to add more
clauses to this definition. The property that we want to hold is that 
we have one clause for each syntactic form, so that we can guarantee that 
the relation is reflexive.

\begin{lemma}[\link{untyped/equiv.v}{Compatible_refl}{Compatible relations are reflexive}]
If we have $[[Compatible RE RV]]$, then both $[[RE]]$ and $[[RV]]$ are reflexive.
\end{lemma}

Now, here is our key definition: 

\begin{definition}[\link{untyped/equiv.v}{CTX}{Contextual preorder}]
Define $[[X |- e CTX e']]$ if there is some compatible, adequate pre-order $[[RE]]$, such 
that $[[X |- e RE e']]$.
\end{definition}

As above, we define contextual equivalence when this preorder holds in both
directions, i.e. $[[X |- e CTX e']]$ and $[[X |- e' CTX e]]$.

What this means is that to show two terms are equivalent, we just need to find
any relation that equates them, as long as that relation has the right
properties. That is a useful definition because it gives us a practical way to
show that terms are contextually equivalent.

\subsection{A logical relation $[[log]]$}

Finally, we can define a \emph{step-indexed} logical relation. This definition is 
mutually defined in terms of a term relation $[[C e1 e2 k]]$, stack relation $[[St s1 s2 k]]$, and value relation $[[V v1 v2 k]]$.

\begin{definition}[\link{untyped/equiv.v}{C}{Step-indexed Logical Relation}]
\[ 
\begin{array}{lclcl} 
   [[C e1 e2 k]] 
      & = & \forall [[s1]], [[s2]], [[St s1 s2 ===>k <s1,e1> <=. <s2,e2> ]] \\
\\
   [[St s1 s2 k]] &=& \forall [[v1]], [[v2]], 
       [[V v1 v2 ===>k <s1,ret v1> <=. <s2,ret v2> ]] \\
\\
   [[V unit unit k]]             &=& \textit{always} \\
   [[V zero zero k]]             &=& \textit{always} \\
   [[V (succ v1) (succ v2) k]]   &=& [[|> k V v1 v2]] \\
   [[V (fun_ x y.e) v2 k]]        &=& \forall [[v]][[v']], 
   [[|> k (V v v' ===> C e[(fun_ x y. e)/y, v1/x] (v2 v')) ]] \\
\end{array}
\]                 
\end{definition}

This relation extends to a step-indexed relation on closing substitutions.
\begin{definition}[Related closing substitutions]\ \\
 $[[ X |- sigma1 log sigma2 @ k ]]$ 
when $[[ V sigma1 x sigma2 x k ]]$
\end{definition}

Which we can use to create scoped preorders on values, terms and stacks.
\begin{definition}[Related values, terms and stacks]\ \\
\begin{enumerate}
\item
$[[ X |- v1 log v2 ]]$ when 
  $[[ X |- sigma1 log sigma2 @ k ]]$ 
  implies $[[ V v1[sigma1] v2[sigma2] k]]$
  for all $[[k]]$.
\item
$[[ X |- e1 log e2 ]]$ when 
  $[[ X |- sigma1 log sigma2 @ k ]]$ implies 
  $[[ C e1[sigma1] e2[sigma2] k]]$, 
  for all $[[k]]$
\item 
$[[ |- s1 log s2 ]]$ when 
  $[[ St s1 s2 k]]$, for all $[[k]]$.
\end{enumerate}
\end{definition}

\section{Examples}
The amazing result is that all of these definitions coincide. All of the pre-orders (and induced equivalence relations) from the previous section relate the same terms.

But why do we have so many definitions? How can we use them?

Pitts' definition of contextual equivalence reassures us that, from our
starting definitions of what it means for programs to approximate one another,
we have the coarsest definition possible. There isn't some other definition of
equivalence out there that would relate more terms. Furthermore, if we find 
any preorder that is compatible and adequate, that relates two terms, then 
we know that they are in the contextual preorder.

The traditional definition of Contextual equivalence justifies the refactoring
that programmers do, or that compilers do when they optimize code. It says
that you can start with any program identify some subterm anywhere and replace
it with something equivalent without changing the semantics of the program.

The CIU pre-order is the most convenient definition for reasoning about
reduction. For example, we can use this definition to show that inlining or
``beta-reduction'' is a sound program transformation.
\begin{lemma}[\link{untyped/equiv_examples.v}{fun_beta}{Beta reduction and expansion}]\ \\
\begin{enumerate}
\item $[[ X |- (fun_ x y.e) v CIU v [v/y, fun_ x y. e/x] ]]$
\item $[[ X |- v [v/y, fun_ x y. e/x] CIU (fun_ x y.e) v ]]$
\end{enumerate}
\end{lemma}

This sort of reasoning is available for any pair of terms, where one steps 
to another.
\begin{enumerate}
\item $[[ X |- e [v/x] CIU let x = ret v in e ]]$
\item $[[ X |- let x = ret v in e CIU e [v/x] ]]$
\end{enumerate}

From these (and other) facts, we can show that the usual definition of untyped
$\beta$-equivalence implies contextual equivalence. However,
$\beta$-equivalence is not as large as contextual equivalence: there are terms
that are not $\beta$-equivalent that are not contextually equivalent.

For example, we cannot use $\beta$-equivalence to show that $[[fun_ x y. x]]$ is 
equal to $[[fun_ x y. x + 0]]$. 


Finally, the logical relation is the most convenient for showing the soundness
of ``$\eta$-reductions''. 

\begin{lemma}[\link{untyped/equiv_examples.v}{fun_eta}{Function $\eta$-reduction}]
$[[ X |- fun_ x y. v y log v ]]$
\end{lemma}

\begin{lemma}[\link{untyped/equiv_examples.v}{nat_eta}{Nat $\eta$-reduction}]
$[[ X |- case v of { 0 => 0; S x => S x } log v ]]$
\end{lemma}


On the other hand, using our definitions, \emph{$\eta$-expansions} are not validated by our 
definitions. We can use the traditional definition of contextual equivalence to show that 

\begin{lemma}[Failure of $\eta$-expansion]
It is not the case that $[[ X |- v CON fun_ x y. v y ]]$ for all $[[v]]$.
\end{lemma}
Choose $[[v]]$ as zero and the context as $[[ # zero ]]$.

\section{Relating the relations}

Finally, let's prove that these relations are equivalent.

\begin{theorem}[\link{untyped/contextual.v}{CTX_Contextual}{The four relations are equivalent}]
We have $[[X |- e CON e']]$ iff $[[X |- e CTX e']]$
iff $[[X |- e CIU e']]$ iff $[[X |- e log e']]$.
\end{theorem}

We don't do this all at once: it takes several steps to make all of these definitions line up.

\begin{figure}
\[
\begin{array}{ccccccc}
        & (1) &           & (6) &           & (4) & \\ 
        & \Rightarrow &   & \Rightarrow &   & \Rightarrow & \\
[[CON]] &     & [[CTX]] &     & [[CIU]] &     & [[log]] \\
        & (2) &           & (5) &           & (3) & \\
        & \Leftarrow &    & \Leftarrow &    & \Leftarrow & \\
\end{array}
\]
\caption{Equivalence steps}
\end{figure}

\begin{enumerate}
\item Show that $[[CON]]$ implies $[[CTX]]$ by showing that it is an adequate and compatible preorder.
\item Show that $[[CTX]]$ implies $[[CON]]$, by using the adequacy of any
  relation in $[[CTX]]$, the fact that contexts preserve compatible relations.
\item Show that $[[log]]$ implies $[[CIU]]$, by showing that the logical relation is 
reflexive.
\item Show that $[[CIU]]$ implies $[[log]]$. This also follows from the reflexivity of the logical relation, and the fact that it is closed under CIU-equivalence.
\item Show that $[[CIU]]$ implies $[[CTX]]$. This requires 
  showing that it is adequate and transitive (easy). To show that it is compatible, we use the fact that it is equivalent to a compatible relation ($[[log]]$).
\item Show that $[[CTX]]$ implies $[[CIU]]$. This happens in two steps, first for closed terms, by induction over the arbitrary stack. Then, we extend the proof to open terms 
by showing that contextual equivalence is closed under substitution.
\end{enumerate}


\subsection{$[[CON]]$ implies $[[CTX]]$}

Showing that $[[CON]]$ implies $[[CTX]]$ means showing that it is an adequate and compatible pre-order.

The reflexivity and transitivity of $[[CON]]$ immediately fall out from the
reflexivity and transitivity of the approximation relation
$\sqsubseteq$. Furthermore, showing that contextual equivalence is adequate is
similarly straightforward. We merely need to use the context that is a single
hole, and the result immediately holds.

However, to show compatibility, we need to be able to compose contexts,
written $[[C1 o C2]]$ and reason about how that composition interacts with
plugging terms.

\begin{lemma}[\link{untyped/contextual.v}{compose_plug}{Compose plug}]
\[ [[ C2 {| C1 {| e |} |} ]] = [[ C1 o C2 {| e |} ]] \]
\end{lemma}

In the compatibility proof, we instantiate premises with the appropriate
contexts. For example, so show that contextual equivalence is compatible for
application expressions, we prove the following sublemma.

\begin{lemma}[\link{untyped/contextual.v}{Compatible_Contextual}{App Compatibility}]
If $[[X |- v1 CON v2 ]]$ and $[[ X |- v1' CON v2' ]]$ then $[[X |- v1 v1' CON v2 v2']]$.
\end{lemma}
\begin{proof}
To show $[[X |- v1 v1' CON v2 v2']]$, we pick an arbitrary context $[[C]]$, and show that 
$[[ C {| v1 v1' |} <= C {| v2 v2' |} ]] $. We instantiate our first assumption
with the context $[[v2 # o C]]$ to conclude that $[[  C{| v2 v1' |} <= C{| v2 v2' |} ]]$.
Then, we instantiate the second assumption with $[[ # v1 o C]]$ to conclude that 
$[[ C{| v1 v1' |} <= C {| v2 v1' |} ]]$. Chaining these approximations together 
transitively gives us the desired result.
\end{proof}

\subsection{Show that $[[CTX]]$ implies $[[CON]]$}.

Next, note that if $[[X |- e1 CTX e2]]$, then we have $[[X |- e1 RE e2]]$ for
some adequate compatible relation $[[RE]]$.

\begin{lemma}[\link{untyped/contextual.v}{CTX_Contextual}{$[[CTX]]$ implies $[[CON]]$} ]
If $[[ X |- e1 CTX e2 ]]$ then $[[ X |- e1 CON e2 ]]$.
\end{lemma}
\begin{proof}
Let $[[C]]$ be an arbitrary context. We want to show that $[[C{|e1|} <= C{|e2|}]]$.
By adequacy, it suffices to show that $[[ null |- C{|e1|} RE C{|e2|} ]]$. 
But this follows by lemma~\ref{lem:Compatible_plug} and the compatibility of $[[CTX]]$.
\end{proof}

\begin{lemma}[\link{untyped/contextual.v}{Compatible_plug}{Compatible plug}]
\label{lem:Compatible_plug}
If $[[RE]]$ and $[[RV]]$ are compatible, then 
$[[ X |- e1 RE e2 ]]$ implies $[[ X |- C{| e1|} RE C{|e2|} ]]$ and
$[[ X |- v1 RV v2 ]]$ implies $[[ X |- C{| v1|} RV C{|v2|} ]]$.
\end{lemma}
\begin{proof} 
This result follows by induction on the structure of $[[C]]$, using the 
compatibility properties of $[[RE]]$ and $[[RV]]$ along with reflexivity.
\end{proof}

\subsection{$[[log]]$ implies $[[CIU]]$}

First, before we reason about $[[log]]$, because we have defined it as a
step-indexed relation, we need to show that it is downward closed. This is not
difficult to do.

Next, we show the fundamental property for this logical relation.

The fundamental property of \emph{binary logical relations} is that they are
reflexive. In other words, we want to show that for any $[[ X |- e ]]$ and we
have $[[ X |- e log e ]]$.  However, we have already observed that reflexivity
is a consequence of compatibility. Therefore, we show that the term and value
relations are compatible.

\begin{lemma}[\link{untyped/equiv.v}{compat_eq}{Logical equivalence is compatible}]
The term and value relations are compatible (see definition ~\ref{def:compatible}).
\end{lemma}

Reflexivity is all we need to show that the logical preorder implies the CIU
preorder. The compatibility relation above gives us reflexivity for our relations 
between terms, values, stacks and closing substitutions.

\begin{lemma}[\link{untyped/equiv.v}{refl_val}{Reflexivity}]\ \\
\begin{enumerate}
\item If $[[ X |- e ]]$ then $[[ X |- e log e ]]$.
\item If $[[ X |- v ]]$ then $[[ X |- v log v ]]$.
\item If $[[ |- s ]]$ then $[[ |- s log s ]]$.
\item If $[[ X |- sigma ]]$ then $[[ X |- sigma log sigma ]]$.
\end{enumerate}
\end{lemma}

\begin{lemma}[\link{untyped/equiv.v}{logtm_CIU}{$[[log]]$ implies $[[CIU]]$}]
If $[[ X |- e log e' ]]$ then $[[ X |- e CIU e' ]]$.
\end{lemma}
\begin{proof}
To show that $[[e]]$ is CIU-related to $[[e']]$, we need to pick an arbitrary stack $[[s]]$ and 
arbitrary substitution $[[sigma]]$, and show that $[[ < s,e[sigma] > <= < s, e'[sigma] > ]]$.
Now, suppose $[[< s,e[sigma] > |-k> < nil, ret v > ]]$ in some number of steps $[[k]]$.
From our reflexivity property, we know that 
$[[ null |- sigma log sigma ]]$ and $[[ |- s log s]]$. 
Therefore, by the definition of the logical relation, 
we know that $[[C e[sigma] e'[sigma] k]]$, and thus,
$[[< s, e[sigma]> <k= < s, e'[sigma] > ]]$.
\end{proof}

\subsection{$[[CIU]]$ implies $[[log]]$}

To show this direction, we first establish that the logical relation is closed under the 
CIU relation.

\begin{lemma}[\link{untyped/equiv.v}{eqtm_closed_CIU}{$[[log]]$ is closed under $[[CIU]]$}]
\label{lem:eqtm_closed_CIU}
If $[[ X |- e log e']]$ and $[[ X |- e' CIU e'' ]]$, then $[[ X |- e log e'']]$.
\end{lemma}
\begin{proof}
Let $k$, $[[ X |- sigma log sigma']]$ be arbitrary. We want to show that 
$[[ C e[sigma] e''[sigma'] k]]$.
This means showing that forall $[[j <= k]]$ and forall stacks $[[ St s s' j]]$, 
we have $[[ <s, e[sigma]> <j= <s', e''[sigma']> ]]$.
By our second assumption, we know that 
$[[ <s', e'[sigma']> <= <s',e''[sigma']> ]]$.
This holds transitively, if we can show 
$[[ <s, e[sigma]> <j= <s', e'[sigma']> ]]$. 
However, that is a consequence of our first assumption as the stacks and 
substitutions are related.
\end{proof}

\begin{lemma}[\link{untyped/equiv.v}{}{$[[CIU]]$ implies $[[log]]$}]
If $[[ X |- e CIU e']]$ then $[[X |- e log e' ]]$.
\end{lemma} 
\begin{proof}
Reflexivity of the logical relation gives use $[[X |- e log e]]$. With 
Lemma~\ref{lem:eqtm_closed_CIU} above, we can conclude $[[ X |- e log e']]$.
\end{proof}

At this point we know that the logical and and CIU preorders coincide.

\subsection{$[[CIU]]$ implies $[[CTX]]$}
To show that $[[CIU]]$ implies $[[CTX]]$, we need to show that it is an adequate, compatible preorder.

Showing that it is adequate and transitive is straightforward from the
definition. To show that it is compatible, we use the fact that it is
equivalent to a compatible relation ($[[log]]$).

\begin{lemma}[\link{untyped/equiv.v}{Compatible_CIU}{Compatibility}]
$[[CIU]]$ is compatible (using the logical relation as the value relation).
\end{lemma}

\subsection{$[[CTX]]$ implies $[[CIU]]$}

This happens in two steps. We first show this result for closed terms. Then,
we extend the proof to open terms by showing that contextual equivalence is
closed under substitution.

\begin{lemma}[\link{untyped/equiv.v}{CTX_ciu}{Closed $[[CTX]]$ implies $[[CIU]]$}]
$[[ null |- e CTX e' ]]$ implies $[[ <s,e> <= <s,e'> ]]$ for any $s$.
\end{lemma}
\begin{proof}
By assumption we know that $[[ null |- e RE e']]$ using some preorder that 
is adequate and compatible.
We prove $[[ <s,e> <= <s,e'> ]]$ by induction on the stack $s$. If the stack is 
empty, then the result follows via adequacy.
If the stack is $[[let x=_ in e2 : s]]$, by compatibility and reflexivity of 
the arbitrary relation we know that 
$[[ null |- let x = e in e2 RE let x = e' in e2 ]]$.
By induction, we know that $[[ <s, let x = e in e2> <= <s, let x = e' in e2> ]]$.
By the fact that approximation is closed under forward and reverse reduction, 
we can conclude $[[ <let x = _ in e2 : s, e> <= <let x = _ in e2 : s, e'> ]]$.
\end{proof}

\begin{lemma}[\link{untyped/equiv.v}{value_substitutivity}{Substitutivity}]
If $[[ X |- e CTX e' ]]$ and $[[ X |- sigma ]]$ then $[[ null |- e[sigma] CTX e'[sigma] ]]$.
\end{lemma}
\begin{proof}
We prove this by induction on the length of $[[X]]$ (i.e. the number of variables in the 
domain of $[[sigma]]$. We can show the substitutivity result for single substitutions by 
using the transitivity of $[[CTX]]$ to join the following results:
\begin{enumerate}
\item $ [[ X |- e [v/x] CTX let x = ret v in e ]]$ (by showing them $[[CIU]]$ equivalent)
\item $ [[ X |- let x = ret v in e CTX let x = ret v in e' ]]$ (by compatibility of any underlying relation in $[[CTX]]$)
\item $ [[ X |- let x = ret v in e' CTX e' [v/x] ]]$ (by showing them $[[CIU]]$ equivalent).
\end{enumerate}
\end{proof}

At this point we have shown that the relations $[[CTX]]$, $[[log]]$ and
$[[CIU]]$ are equivalent. Because of this equivalence, it is now not difficult to 
show that $[[CTX]]$ is compatible.


\section{Further Reading}
This chapter is inspired by Pitts\cite{pitts:DagSemProc.10351.6}. Similar
material is available in PFPL chapter 47~\cite{harper:pfpl}, although that is for a typed
language, not the untyped lambda calculus. Furthermore, similar mechanized results for CBPV 
are available in Forster et al.~\cite{forster:cbpv}.
