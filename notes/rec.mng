\chapter{\rec: Recursive definitions}

In this chapter, we introduce our first \emph{effectful} programming language:
a fine-grained call-by-value language with recursive definitions, called
\rec. That effect is \emph{nontermination}, where evaluating a program may not
actually result in a value.

We will add nontermination through two sorts of recursive definitions: first
through recursive values and then through recursive types.

\section{Recursive definitions in CBV languages}

To build intuition about the language structures we 
are adding in this section, we will first start out 
with some examples written in the OCaml programming 
language.

For example, a straightforward definition of the 
doubling function, which we previously implemented 
via primitive recursion, looks like this: 

\code{../ocaml/plst/lib/recursion.ml}{double}

However, we are not limited to primitive recursion in 
OCaml. We can do much more.

\subsection{Mutual recursion via recursive tuples}

First, OCaml allows the definition of functions that are 
\emph{mutually} recursive using the keywords \cd{rec ... and}. Any
definition in a block can refer to any other in the same 
block. 

A simple example is the mutual definition of the odd and even functions. 

\code{../ocaml/plst/lib/recursion.ml}{mutual}

But what if we didn't have \cd{and} available? It turns out that there 
are two ways that we could replace the code above. 

One way is to inline one recursive definition into another. This requires 
us to repeat the definition of one of the operations later. 

\code{../ocaml/plst/lib/recursion.ml}{single}

Beki\'c's theorem\footnote{\url{https://en.wikipedia.org/wiki/Beki%C4%87%27s_theorem}} 
states that this always works. 

Another option is to use recursion on products of functions, instead of just
on functions. In this version, to make the code a little easier to read, we
first define a record type containing odd and even functions (i.e. a product).
Then, by using recursion through the product value, we can mutually 
define the two functions.

\code{../ocaml/plst/lib/recursion.ml}{product}

\subsection{Another example with recursive tuples}

However, it turns out that in OCaml there are definitions of recursive product values 
where the recursive reference is not hidden in a function body. 

Consider the following stream type:

\code{../ocaml/plst/lib/recursion.ml}{stream}

Perhaps surprisingly OCaml accepts the definition of \cd{zeros} above. This line 
defines \cd{zeros} as a recursive value, represented by a cycle in the heap, and 
displayed as \cd{Cons (0, <cycle>)}.

We are limited with what we can do with the \cd{stream} type. For example, although we 
define a mapping operation, thus:

\code{../ocaml/plst/lib/recursion.ml}{map}

any use of the mapping function will go into an infinite loop:

\code{../ocaml/plst/lib/recursion.ml}{ones}

We cannot use the stream for termination. Instead, we need to find some other 
finite value to iterate over. 

For example, we can access any finite number of zeros from the stream:

\code{../ocaml/plst/lib/recursion.ml}{streamex}

But there is a natural number that we could give to \cd{take} that would 
cause it to diverge.

\code{../ocaml/plst/lib/recursion.ml}{takeomega}

\subsection{Recursive values via recursive types}

So far, we have been showing examples that use recursive value definitions as well 
as recursive types. But, it turns out that we only need the latter to define 
the former. At least for recursive functions. The trick is that we can use a 
recursive type allow the Y-combinator to type check in OCaml. 

Let's use a simple \cd{length} function as an example.

\code{../ocaml/plst/lib/recursion.ml}{length}

If we knew how big of list we wanted to call the length function on, then we would not 
need to use recursion for this definition. For example, say we only needed it to 
work for lists of size 0 or 1. Then we can use the definition of \cd{length2} below:

\code{../ocaml/plst/lib/recursion.ml}{length2}

When given a longer list, this function fails. But, this is a pretty long definition. 
Let's refactor it:

\code{../ocaml/plst/lib/recursion.ml}{refactored}

The refactored version is easy to see how to extend it to work with longer lists.

\code{../ocaml/plst/lib/recursion.ml}{length4}

More generally, our recursive definition is 

\code{../ocaml/plst/lib/recursion.ml}{lengthrec}

which could also be written as:

\code{../ocaml/plst/lib/recursion.ml}{lengthrec2}

Here's the big leap! If we could do self application, then maybe we would 
write this example without using \cd{rec}.

\code{../ocaml/plst/lib/recursion.ml}{self}

But this code does not type check in OCaml.

To get it to type check, we need to introduce a recursive type so that we 
can apply a function to itself. The key part of the type definition is 
that recursive reference occurs to the left of the arrow in its own definition. 
This is called a negative occurrence and would be rejected by Rocq, but it is 
not an inductive type.

\code{../ocaml/plst/lib/recursion.ml}{dom}

Indeed, with this type, we can write the simplest infinite loop
in the untyped  lambda-calculus. This term steps immediately to itself.

\code{../ocaml/plst/lib/recursion.ml}{loop}

Putting this idea to work, we can use this type get the length function above
to type check. 

\code{../ocaml/plst/lib/recursion.ml}{lengthdom}

We can also factor out the call-by-value Y-combinator, which is the essence of
the recursive definition.

\code{../ocaml/plst/lib/recursion.ml}{y}

\section{A fine-grained CBV language}

Now, before we consider the semantics of recursive definitions, let's refactor the
base language to make it easier to extend. At the same time, we will add a few
more common language features, such as products, sums and an empty type.

Here is the \link{rec/syntax.sig}{Val}{syntax} of the base language that we
will work with.

\[
\begin{array}{lcll}
[[tau]] &::=& [[Void]]\ |\ [[Nat]]\ |\ [[tau1 -> tau2]]
          |\ [[tau1 * tau2]]\ |\ [[tau1 + tau2]] & \mbox{types} \\

[[v]] &::=& [[x]]\                  & \mbox{Variables} \\
      & | & [[k]]\                  & \mbox{Natural numbers} \\
      & | & [[\x. e]]\              & \mbox{Functions} \\
      & | & [[(v1,v2)]]\            & \mbox{Pairs} \\
      & | & [[inj1 v]]\ |\ [[inj2 v]] & \mbox{Sums} \\ 
\\
[[e]] &::=& [[v1 v2]]                 & \mbox{application} \\
      & | & [[succ v]]                & \mbox{successor} \\ 
      & | & [[case v of { 0 => e1 ; S x => e2 } ]]         & \mbox{test for zero} \\
      & | & [[prj1 v]]\ |\ [[prj2 v]]\ & \mbox{projection} \\
      & | & [[case v of { inj1 x => e1 ; inj2 x => e2 } ]] & \mbox{case} \\
      & | & [[ret v]]                 & \mbox{value} \\
      & | & [[let x = e1 in e2]]      & \mbox{sequencing} \\
\end{array}
\]

The first thing to notice about this language is that it makes a 
syntactic distinction between values and expressions. These two grammars 
are mutually defined. Terms appear inside values in function bodies. 
Values can appear in terms in several ways. First by being ``returned'' via $[[ret v]]$. 
(Some versions of fine-grained CBV make the $\ottkw{ret}$ implicit, as it often 
can be inferred from context. For clarity, we will make it explicit.)

Furthermore, notice that almost all terms restrict their ``active'' subterms
to be values. The arguments of $[[succ v]]$, the scrutinee for the various
forms of pattern matching, and both the function and the argument in an
application must be values. 

There are several reasons for this modification. The one that we will discuss
now is that it allows us to extend the small-step semantics with new
constructs while skipping the associated congruence rules in the operational
semantics. All we need to add are the main computation rules. As the active
part of the expression must be a value, we do not need to add any rules to
evaluate that subexpression.

\begin{definition}[\link{rec/reduction.v}{step}{Active rules}]
\drules[s]{$[[e ~> e']]$}{term $e$ steps to $[[e']]$}
{beta,succ,case-zero,case-succ,prjOne,prjTwo,case-injOne,case-injTwo}
\end{definition}

In this language, the let term controls the sequencing of evaluation. We only
have a single congruence rule, which evaluates right-hand side of a let
expression if it is not a returned value.

\drules[s]{$[[e ~> e']]$}{term $e$ steps to $[[e']]$}
{let-ret,let-cong}

In this language, there is no question about the ordering in which evaluation
happens. In some CBV languages, we might evaluate the argument of an
application before we evaluate the function. Or we might evaluate the function
before the argument.  Or, the language might say that this order is undefined,
giving flexibility to the language implementation. For example, the OCaml
byte code compiler chooses a different order than the native code compiler.

In STLC, the order doesn't matter, and either version will produce the same
result. However, in some effectful languages, the order of this evaluation can
matter.

Therefore, to rule out ambiguity, this language puts the onus 
on the programmer to explicitly say what they want, by 
writing either

\[ [[ let x1 = e1 in let x2 = e2 in x1 x2]] 
   \qquad \mbox{or} \qquad 
  [[ let x2 = e2 in let x1 = e1 in x1 x2]] \]

\subsection{Type system}

With a syntactic distinction between values and expressions, we have two
separate typing judgments: one for values and one for terms.

\begin{definition}[\link{rec/typing.v}{typing}{Type system}]\ \\
\drules[tv]{$[[G ||- v : tau ]]$}{in context $[[G]]$, value $v$ has type $[[tau]]$}
{lit,var,abs,pair,injOne,injTwo}
\drules[te]{$[[G ||- e : tau ]]$}{in context $[[G]]$, term $e$ has type $[[tau]]$}
{ret,let,app,prjOne,prjTwo,case}
\end{definition}

These two judgments are mutually defined. 

\subsection{Recovering expressiveness}

Note that this restriction does not limit the expressiveness of the
language. We can \emph{define} the standard expression forms.

For example, instead of application of the form $[[e1 e2]]$, the only
application form in this language is $[[v1 v2]]$.

\begin{definition}[\link{rec/extensions.v}{eagerlet}{Eager let}]
Define $[[let x <= e1 in e2]]$ as $[[e2 [v/x] ]]$ when $[[e1]]$ is $[[ret v]]$ and 
$[[let x = e1 in e2]]$ otherwise.
\end{definition}

We use this eager let in the definition of some derived forms.

\begin{definition}[\link{rec/extensions.v}{app\_tm}{Extended Application}]
Define $[[e1 e2]]$ as $[[let x1 <= e1 in let x2 <= e2 in x1 x2]]$.
\end{definition}

\begin{definition}[\link{rec/extensions.v}{succ\_tm}{Extended Successor}]
Define $[[succ e]]$ as $[[let x <= e in succ x]]$.
\end{definition}

The reason for the eager let is so that we can prove that our derived forms
have the appropriate operational behavior.

For example, we can prove the following lemmas about the behavior of the 
extended application form.

\begin{lemma}[\link{rec/extensions.v}{}{Application steps}]
\begin{enumerate}
\item $[[ (ret(\x.e)) (ret v) ~> e[v/x] ]]$. 
\item If $[[e1 ~> e1']]$ then $[[e1 e2 ~>* e1 e2']]$.
\item If $[[e2 ~> e2']]$ then $[[v e2 ~>* v e2']]$.
\end{enumerate}
\end{lemma}

\section{Recursive values}

Now, let's add general recursion. We will do so by adding a new form of value,
called a \emph{recursive value}, written $[[rec x . v]]$. Here, the variable
$[[x]]$ is bound inside $v$ and refers to the whole value.

\[ [[v]] ::= [[rec x . v]] \] 

Usually $[[v]]$ will be a function, and this will give is a way to define 
recursive functions. But it doesn't have to be, as we saw in OCaml.

The typing rule includes an auxiliary judgment written $[[tau ok]]$ that
specifies which types may be used in recursive definition.

\[ \drule{tv-rec} \]

For now, the rules specify that function and product types are ok.

\[ \drule{fun-ok} \qquad \drule{prod-ok} \]

Analogously, we need small-step rules to unwind the value when that type is
used.

\[ \drule{s-app-rec} \]
\[ \drule{s-prjOne-rec} \qquad  \drule{s-prjTwo-rec} \]

Why do we do it this way? Because of our syntactic separation between values
and computations!  We can only substitute values for values.

\section{Recursive types}

Finally we add recursive types to the language.  This means adding a
recursive definition form $\mu$ and type variables to the syntax of
types.  And, in the syntax of terms, we introduce two coercions, for
introducing and eliminating values with the recursive type.

\[ 
\begin{array}{lcll}
[[tau]] &::=& [[alpha]]\ |\ [[mu alpha . tau]] & \mbox{variables and recursive types} \\
[[v]]   &::=& [[fold v]]                       & \mbox{introduction form} \\
[[t]]   &::=& [[unfold v]]                     & \mbox{elimination form} \\
\end{array}
\]

Although we have type variables in our types, they are only used for recursion in this language. 
It will be an invariant of our type system that we only work with closed 
types. Furthermore, a recursive type $[[mu alpha.tau]]$ is closed, if and only if 
its unfolding $[[tau [mu alpha.tau/alpha] ]]$ is also closed.

The introduction form creates a value with a recursive type and the elimination rule 
exposes its structure.
\[
\drule{tv-fold}
\drule{te-unfold}
\]

The single new rule of the operational semantics removes the coercions.

\[ \drule{s-unfold} \]

\subsection{Recursive type variations}

The presence of $[[fold v]]$ and $[[unfold v]]$ introduction and elimination
forms, means that language includes \emph{iso-}recursive types. The types
$[[mu alpha.tau]]$ and $[[tau [mu alpha.tau/alpha] ]]$ are isomorphic, but not
  equal types. The introduction and elimination terms are coercions for the
  isomorphism.  Iso-recursive types are the most straightforward way to add
  recursive types to a language, as it only requires $\alpha$-equivalence for
  type equality.

Alternatively, some languages include a definitional type equivalence, i.e. an
equivalence relation that states when two types are equal and is coarser than
$\alpha$-equality. In this case, the language includes some sort of conversion rule, 
giving terms any equivalent types. This conversion rule can make the metatheory of the 
language more complex to work with as often the type system is not syntax-directed.

\section{Type safety}

Let's consider type safety for \rec. Notably, we will do so by proving preservation and 
progress with the small-step semantics. While it is possible to define a big-step semantics
for this language, the fact that computations may diverge means that we have to be careful.

\section{Further reading}

Fine-grained CBV is from~\cite{LEVY:fgcbv} as a way to control the sequence of effects. 
The definition of \emph{eager let} is from Forster et al.~\cite{forster:cbpv}.
