
grammar

tau {{ tex \tau }} :: 'ty_'  ::= 
  | tau1 -> eff tau2 ::  :: ArrEff
  {{ tex [[tau1]] \stackrel{[[eff]]}{[[->]]} [[tau2]] }}
  | tau1 * eff  tau2 ::  :: ProdEff
  {{ tex [[tau1]] \stackrel{[[eff]]}{\times} [[tau2]] }}

eff {{ tex \varepsilon }} :: 'eff_' ::= 
  | bot         ::   :: Bot
   {{ tex \bot }}
  | top         ::   :: Top 
   {{ tex \mathsf{DIV} }}
  | eff1 + eff2 ::   :: join
   {{ tex [[eff1]] \oplus [[eff2]] }}
  | ( eff )     :: M :: paren

T :: 'tms_' ::= 
  | vals        :: M :: Vals
  {{ tex \textit{all values} }}
  | C tau eff   :: M :: LRCE
  {{ tex \mathcal{C}[\![ [[tau]] ]\!]^{[[eff]]} }}

terminals :: '' ::=
  | <:          ::   :: sub
  | (+)         ::   :: oplus
     {{ tex \oplus }}

formula :: 'formula_' ::= 
  | eff1 <: eff2 ::   :: eff_le
  | eff1 = eff2  ::   :: eff_equal
  | G |= e : tau  @ eff  ::   :: sem_typing_eff

defns 
JSub :: '' ::= 

defn 
tau1 <: tau2 ::   :: sub  :: ''
by

------------------ :: refl
tau <: tau

tau2 <: tau1 
eff1 <: eff2
tau1' <: tau2'
---------------------------------------- :: arr
tau1 -> eff1 tau1' <: tau2 -> eff2 tau2

defns
JREC_OK :: '' ::= 

defn 
tau ok ::  :: rec_ok :: ''
by


------------------ :: ok_fun_eff
(tau1 -> top tau2) ok

------------------ :: ok_prod_eff
(tau1 * top tau2) ok


defns 
JRecTyping :: '' ::= 

defn 
G ||- v : tau ::  :: typing_val :: 'tv_' 
{{ tex [[G]] \vdash [[v]] \in [[tau]] }}
by

G, x:tau1 ||- e : tau2 @ eff1
eff1 <: eff2 
------------------------  ::  abs_eff
G ||- \x.e : tau1 -> eff2 tau2

G ||- v1 : tau1
G ||- v2 : tau2 
------------------------- :: pair_eff
G ||- ( v1 , v2 ) :  tau1 * eff tau2 


defns 
JEffTyping :: '' ::= 

defn 
G ||- e : tau @ eff  ::  :: typing_eff_tm :: 'tee_'
{{ tex [[G]] \vdash [[e]] \stackrel{[[eff]]}{\in} [[tau]] }}
by

G ||- v : tau 
------------------------ :: ret
G ||- ret v : tau @ bot

G ||- e1 : tau1 @ eff1
G, x : tau1 ||- e2 : tau @ eff2 
-------------------------------------- :: let
G ||- let x = e1 in e2 : tau @ eff1 + eff2

G ||- v1 : tau1 -> eff tau2  
G ||- v2 : tau1 
--------------------- :: app
G ||- v1 v2 : tau2 @ eff

G ||- v : tau1 * eff tau2
------------------------- :: prj1
G ||- prj1 v : tau1 @ eff

G ||- v : tau1 * eff tau2
------------------------- :: prj2
G ||- prj2 v : tau2 @ eff

G ||- v : tau1 + tau2
G , x1 : tau1 ||- e1 : tau @ eff
G , x2 : tau2 ||- e2 : tau @ eff
----------------------------------------------- :: case
G ||- case v of { inj1 x1 => e1 ; inj2 x2 => e2 } : tau @ eff

G ||- v : Nat
G ||- e1 : tau @ eff
G , x2 : Nat ||- e2 : tau @ eff
----------------------------------------------- :: ifz
G ||- case v of { 0 => e1 ; S x2 => e2 } : tau @ eff

G ||- v : mu alpha . tau  
------------------------------------- :: unfold
G ||- unfold v : tau [mu alpha.tau/alpha] @ top

G ||- e : tau @ eff1    
eff1 <: eff2 
-------------------------------------- :: sub_eff
G ||- e : tau @ eff2


