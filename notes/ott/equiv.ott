grammar

e :: '' ::= 
  | C {| e |}   ::   :: plug
  {{ tex [[C]] \{\!| [[e]] |\!\} }}

v :: '' ::= 
  | C {| v |}   ::   :: plug
  {{ tex [[C]] \{\!| [[v]] |\!\} }}

phi {{ tex \phi }} :: 'iProp_' ::= 
  | V v1 v2         :: M :: VPE
   {{ tex \mathcal{V}[\![\, [[v1]]\ \leq [[v2]] ]\!] }}
  | C e1 e2         :: M :: CPE
   {{ tex \mathcal{C}[\![\, [[e1]]\ \leq [[e2]] ]\!] }}
  | St s1 s2        :: M :: StPE
   {{ tex \mathcal{S}[\![\, [[s1]]\ \leq [[s2]] ]\!] }}
  | m1 <=. m2        :: M :: Approx
   {{ tex [[m1]] \sqsubseteq^\cdot [[m2]] }}

t :: '' ::= 
  | e ::  :: Term
  | v ::  :: Value

scope , X :: '' ::= 
  | null                ::    :: empty
   {{ tex \emptyset }}
  | x                   ::    :: single_
  | scope1 , scope2     ::    :: cons

R {{ tex \mathcal{R} }} , RE {{ tex \mathcal{R}_\mathcal{E} }} , RV {{ tex \mathcal{R}_\mathcal{V} }} :: '' ::= 
  | ==N              ::    :: nat_eq
  {{ tex \equiv_{\mathbb{N} } }}
  | USE                 ::    :: USE
  {{ tex \leq  }}
  | CON                 ::    :: C
  {{ tex \leq_{\textit{C} } }}
  | CIU                 ::    :: CIU
  {{ tex \leq_{\textit{CIU} } }}
  | CTX                 ::    :: CTX
  {{ tex \leq_{\textit{CTX} } }}
  | log                 ::    :: log
  {{ tex \leq_{\textit{log} } }}
  | =CON                 ::    :: eC
  {{ tex \equiv_{\textit{C} } }}
  | =CIU                 ::    :: eCIU
  {{ tex \equiv_{\textit{CIU} } }}
  | =CTX                 ::    :: eCTX
  {{ tex \equiv_{\textit{CTX} } }}
  | =log                 ::    :: elog
  {{ tex \equiv_{\textit{log} } }}

C :: 'C_' ::= 
  | #               ::  :: hole
   {{ tex \# }}
  | C v2            ::  :: app1
  | v1 C            ::  :: app2 
  | let x = C in e2 ::  :: let1
  {{ tex \ottkw{let}\, [[x]]\,=\,[[C]]\,\ottkw{in}\,[[e2]] }}
  | let x = e1 in C ::  :: let2
  {{ tex \ottkw{let}\, [[x]]\,=\,[[e1]]\,\ottkw{in}\,[[C]] }}
  | ret C           ::  :: ret 
  | prj1 C          ::  :: prj1
  | prj2 C          ::  :: prj2
  | case C of { 0 => e0 ; S y => e1 } ::  :: ifz1
  | case v of { 0 => C ; S y => e1 }  ::  :: ifz2
  | case v of { 0 => e0 ; S y => C }  ::  :: ifz3
  | case v of { inj1 x1 => e1 ; inj2 x2 => e2 } ::   :: case1
  | case v of { inj1 x1 => e1 ; inj2 x2 => e2 } ::  :: case2
  | case v of { inj1 x1 => e1 ; inj2 x2 => e2 } ::  :: case3
  | succ C          ::  :: succ
  | ( C , v2 )      ::  :: prod1
  | ( v1 , C )      ::  :: prod2
  | inj1 C          ::  :: inj1
  | inj2 C          ::  :: inj2
  | fun_ x y . C    ::  :: abs
  | C1 o C2         ::  :: compose 
   {{ tex [[C1]] \circ [[C2]] }}


formula :: 'formula_' ::=
  | e1 == e2            ::    :: closed
  | scope |- e          ::    :: scope_check
  | scope |- sigma      ::    :: closing_sub
  | scope |- e1 RE e2   ::    :: scoped_relation
  | scope |- v1 RV v2   ::    :: scoped_value_relation
  | |- s                ::    :: scoped_stack
  | |- s1 RE s2         ::    :: stack_relation
  | e1 USE e2           ::    :: closed_relation
  | G |- e1 == e2 : tau ::    :: typed_eq
  | Reflexive RE        ::    :: Reflexive
  | Transitive RE       ::    :: Transitive
  | Adequate RE         ::    :: Adequate
  | Compatible RE RV    ::    :: Compatible
  | halts e             ::    :: halts_e
  | halts m             ::    :: halts
  | halts k m           ::    :: halts_n
    {{ tex \ottkw{halts}^{[[k]]} [[m]] }}
  | m |- k > m'         ::    :: steps_n
    {{ tex [[m]] \mapsto^{[[k]]} [[m']] }}
  | e <= e'             ::    :: approx_u
    {{ tex [[e]] \sqsubseteq [[e']] }}
  | m <= m'             ::     :: approx
    {{ tex [[m]] \sqsubseteq [[m']] }}
  | m < k = m'          ::     :: approx_n
    {{ tex [[m]] \sqsubseteq^{[[k]]} [[m']] }} 
  | X |- sigma1 log sigma2 @ k :: M :: RelSigmak
   {{ tex [[X]] \vdash [[sigma1]] \leq_\textit{log}^{[[k]]} [[sigma2]]  }}
  | X |- sigma1 log sigma2 :: M :: RelSigma
   {{ tex [[X]] \vdash [[sigma1]] \leq_\textit{log} [[sigma2]]  }}

  | m ==N m'            ::    :: mach_eq
    {{ tex [[m]] \equiv_{\mathbb{N} } [[m']] }} 
  | G |- e1 RE e2 : tau ::    :: typed_tm_eq
  | G |- v1 V2 v2 : tau ::    :: typed_val_eq
  | V v1 v2 tau         ::    :: logical_val
  {{ tex \mathcal{V}[\![ [[v1]] \equiv [[v2]] \in [[tau]] ]\!] }}
  | C e1 e2 tau         ::    :: logical_tm
  {{ tex \mathcal{C}[\![ [[e1]] \equiv [[e2]] \in [[tau]] ]\!] }}
  | St s1 s2 tau        ::   :: logical_st
  {{ tex \mathcal{S}[\![ [[s1]] \equiv [[s2]] \in [[tau]] ]\!] }}
  | G |- sigma          ::   :: check_sigma
  | G |- sigma1 R sigma2 ::   :: log_sigma

  | G |- t R t' : tau    ::   :: arb_rel
  | G |- t : tau         ::   :: arb_ty
    {{ tex [[G]] \vdash [[t]] \in [[tau]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


defns
  JStep :: '' ::=


defn
m |- k >  m' ::  :: step_n :: 'sn_'
{{ com counted multi-step evaluation }}
{{ tex [[m]] \mapsto^{[[k]]} [[m']] }}
by

------------------- :: refl
m |-0> m

m0 |-> m1
m1 |-k> m2
------------------- :: trans
m0 |-S k> m2
