% This file includes the specification of the core grammar, operational semantics
% and typing rules 
%
% It also includes typesetting directives that control how the language is presented
% in the lecture notes.

%% STLC language

indexvar index, n ::= {{ coq nat }} 

metavar x, y, z, f, g ::=
  {{ com variables }}
  {{ lex alphanum }}

grammar

nat , i, j, k :: 'k_' ::= 
{{ com natural number constants }}
  | 0               ::   :: Zero
  | S k             ::   :: Succ
  | 1               ::   :: One
  | 2               ::   :: Two
  | 3               ::   :: Three
  | 4               ::   :: Four  
  | 5               ::   :: Five
  | k1 + k2         ::   :: Plus
  | k1 - k2         ::   :: Minus
  | ( k )           :: S :: Paren

vs :: 'vs_' ::= 
{{ com sets of variables }}
  | { x }           ::   :: Single
  | emptyset        ::   :: Empty
  | vs1 U vs2       ::   :: Union
  | vs1 - vs2       ::   :: Minus
  | vars            ::   :: Total_set
    {{ tex \mathcal{V} }}
  | fv ( e )        :: M :: FV 
  | dom xi          :: M :: Dom_ren
  | rng xi          :: M :: Rng_ren
  | dom sigma       :: M :: Dom_sub
  | fv ( rng sigma ) :: M :: Fv_Rng_sigma
  | dom G           :: M :: Dom_ctx
  | ( vs )          :: S :: Paren

xi {{ tex \xi }} :: 'ren_' ::= 
{{ com renaming: map all variables in scope to new names }}
  | y / x           ::   :: Single
  | null            ::   :: Empty
  | xi1 , xi2       ::   :: Append
  | ( xi )          :: S :: Paren

sigma {{ tex \sigma }} , rho {{ tex \rho }} :: 'sub_' ::= 
{{ com substitution and environments: map all variables in scope to tersm }}
  | e / x           ::   :: Single
  | null            ::   :: Empty
  | sigma1 , sigma2 ::   :: Append
  | ( sigma )       :: S :: Paren

G {{ tex \Gamma }} , D {{tex \Delta}} :: 'ctx_' ::= 
{{ com typing contexts: map all variables in scope to types }}
  | x : tau         ::    :: Single {{ tex [[x]]\! :\![[tau]] }}
  |                 ::    :: Nil
  | G1 , G2         ::    :: Append 
  | ( G )           :: S  :: Paren

tau {{ tex \tau }} :: 'ty_' ::= 
{{ com types }}
  | Nat             ::   :: Nat     {{ com base type: natural numbers }}
  | tau1 -> tau2    ::   :: Arrow   {{ com function types }}
  | G x             :: M :: Ctx     {{ com lookup from typing context }}
  | ( tau )         :: S :: Paren


e :: 'tm_' ::= 
{{ com terms }}
  | k                ::   :: Lit     {{ com natural number constant }}
  | x                ::   :: Var       {{ com variable }}
  | xi x             :: M :: Renaming  {{ com renamed variable }}
  | sigma x          :: M :: VarSub    {{ com lookup from substitution }}

  | let x = e1 in e2 ::   :: Let

  | \ x . e          ::   :: Abs       {{ com function definition }}
    {{ tex \lambda [[x]]. [[e]] }}

  | \ x : tau . e    :: S :: AAbs {{ com function definition (annotated with type) }}
    {{ tex \lambda [[x]]\!:\![[tau]]. [[e]] }}

  | e1 e2            ::   :: App        {{ com function application }}
    {{ tex [[e1]] \; [[e2]] }}   

  | e [ sigma ]      :: M :: SubstOp    {{ com substitution }}
 
  | e < xi >         :: M :: RenOp      {{ com renaming }}

  | < rho , e >      :: M :: Closure    


  | succ e           ::   :: Succ

  | nrec e of { 0 => e0 ; S x => e1 }  ::   :: Nrec 
      {{ com recursor for natural numbers }}

  | ( e : tau )      ::   :: Ann        {{ com type annotation }}

  | ( e )            :: S :: Paren      {{ com parenthesis }}

v , w :: 'v_' ::= 
{{ com values }}

  | \ x . e         ::   :: Lam

  | k               ::   :: Lit

  | succ v          ::   :: Succ

  | v [ sigma ]     :: M :: SubstOp

  | v < xi >        :: M :: RenOp

  | rho x           :: M :: LookupRho

  | < rho , e >     :: M :: Clos

  | ( v )           :: S :: Paren

S  :: 'tms_' ::= 
{{ com sets of terms }} 
  | nats            ::   :: Nat
  | V tau           :: M :: LRV
   {{ tex \mathcal{V}[\![ [[tau]] ]\!] }}
  | C tau           :: M :: LRC
   {{ tex \mathcal{C}[\![ [[tau]] ]\!] }}
  | { e | formula } :: M :: Comprehension
   {{ tex \{ [[e]]\ |\ [[formula]]\, \} }}
  | S1 => S2        :: M :: Function
  | S1 * S2         :: M :: Product
  

U  :: 'tms_' ::= 
{{ com sets of substitutions }} 
  | [ G ]         :: M :: LRG
   {{ tex \mathcal{G}[\![ [[G]] ]\!] }}
  | { sigma | formula } :: M :: SComprehension
   {{ tex \{ [[sigma]]\ |\ [[formula]]\, \} }}


subrules
  v <:: e

parsing
ty_Arrow right ty_Arrow
tm_Abs right tm_App
tm_App left tm_App

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar


terminals :: 'terminals_' ::=
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ok                ::   :: ok            {{ tex \mathsf{ok} }}
  | fv                ::   :: fv            {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom           {{ tex \mathsf{dom} }}
  | rng               ::   :: rng           {{ tex \mathsf{rng} }}
  | ==                ::   :: equiv         {{ tex \equiv }}
  | elem              ::   :: elem          {{ tex \in }}
  | notin             ::   :: notin         {{ tex \not\in }}
  | <=                ::   :: check         {{ tex \Leftarrow }}
  | =>                ::   :: infer         {{ tex \Rightarrow }}
  | =>*               ::   :: minfer        {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow         {{ tex \to }}
  | /\                ::   :: ilam          {{ tex \mathrm{\Lambda} }}
  | []                ::   :: box           {{ tex \Box }}
  | |-                ::   :: entails       {{ tex \vdash }}
  | |=                ::   :: proves        {{ tex \vDash }}
  | /=                ::   :: neq           {{ tex \neq }}
  | |>                ::   :: cast          {{ tex \triangleright }}
  | _                 ::   :: blank         {{ tex \_ }}
  | ~>                ::   :: step          {{ tex \leadsto }}
  | ~>*               ::   :: multistep     {{ tex \leadsto^{\ast} }}
  | empty             ::   :: empty         {{ tex \varnothing }}
  | hole              ::   :: hole          {{ tex \circ }}
  | ~                 ::   :: twiddle       {{ tex \sim }}
  | ~~                ::   :: compatible    {{ tex \asymp }}
  | '|'               ::   :: bar           {{ tex | }}
  | o                 ::   :: bullet        {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | ==>               ::   :: impl          {{ tex \implies }}
  | U                 ::   :: cup           {{ tex \cup }}
  | emptyset          ::   :: emptyset      {{ tex \emptyset }}
  | <                 ::   :: langle        {{ tex \langle }}
  | >                 ::   :: rangle        {{ tex \rangle }}
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | implies           ::   :: implies       {{ tex \mathit{implies} }}
  | and               ::   :: and           {{ tex \mathit{and} }}
  | or                ::   :: or            {{ tex \mathit{or} }}
  | nats              ::   :: nats          {{ tex \mathbb{N} }}
  | forall            ::   :: forall        {{ tex \forall }}
  | exists            ::   :: exists        {{ tex \exists }}
  | nrec_           ::   :: nrec_k
   {{ tex \ottkw{nrec} }}


formula :: 'formula_' ::=
  | judgement                  ::   :: judgement
  | formula1 .. formulan       ::   :: dots
  | x : tau elem G             ::   :: inG
  | formula1 and formula2      ::   :: and
  | formula1 implies formula2  ::   :: implies
  | e elem S                   ::   :: tmelem
   {{ tex [[e]] \in [[S]] }}
  | forall e , formula         ::   :: forall_quant
   {{ tex \forall [[e]], [[formula]] }}
  | forall x elem S , formula         ::   :: forall_elem_quant
   {{ tex \forall [[x]][[elem]][[S]],[[formula]] }}
  | exists e , formula         ::   :: exists_quant
   {{ tex \exists [[e]], [[formula]] }}
  | sigma elem  U              ::   :: sem_sub
  | G |= e : tau               ::   :: sem_typing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyping :: '' ::=

defn

G |- e : tau   ::   :: typing :: 't_'
{{ com Typing }}
{{ tex [[G]] \vdash [[e]] \in [[tau]] }}
by

------------ :: lit
G |- k : Nat

x : tau elem G
----------- :: var
G |- x : tau

G |- e1 : tau1
G , x : tau1 |- e2 : tau2
----------------------------- :: let
G |- let x = e1 in e2 : tau2

G |- e : Nat 
---------------------- :: succ
G |- succ e : Nat

G |- e : Nat 
G |- e0 : tau
G , x : Nat |- e1 : tau -> tau
------------------------------- :: nrec
G |- nrec e of { 0 => e0 ; S x => e1 } : tau

G, x:tau1 |- e : tau2
------------------------  ::  abs
G |- \x.e : tau1 -> tau2


G |- e1 : tau1 -> tau2
G |- e2 : tau1
--------------------------- ::  app
G |- e1 e2 : tau2



defns
JSmall :: '' ::=

defn
e ~> e' ::   :: step :: 's_'
{{ com small-step operational semantics }}
by

----------------------------------  :: letv
let x = v in e ~> e [v/x]

e1 ~> e1'
------------------------------------  :: let_cong
let x = e1 in e2 ~> let x = e1' in e2

----------------------------------  :: beta
(\x. e) v ~> e [ v / x]


e1 ~> e1'
------------------------  :: app_cong1
e1 e2 ~> e1' e2

e2 ~> e2'
------------------------  :: app_cong2
v e2 ~> v e2


------------------------- :: succ_lit
succ k ~> S k

e ~> e'
------------------------  :: succ_cong
succ e ~> succ e'


-------------------------- :: nrec_zero
nrec 0 of { 0 => e1 ; S x =>  e2 } ~> e1

----------------------------------------------- :: nrec_succ
nrec (S k) of { 0 => e1 ; S x => e2 } ~> (e2[k/x]) (nrec k of {0 => e1 ; S x => e2})

e ~> e'
--------------------------------- :: nrec_cong
nrec e of { 0 => e1 ; S x => e2 }  ~> nrec e' of { 0 => e1; S x => e2 }

defn
e ~>* e' ::  :: multi :: 'ms_'
{{ com multi-step evaluation }}
by

------------------- :: refl
e ~>* e

e0 ~> e1
e1 ~>* e2
------------------- :: trans
e0 ~>* e2


defn
e ~ k >  e' ::  :: ms_k_ :: 'ms_k_'
{{ com counted multi-step evaluation }}
{{ tex [[e]] \leadsto^{[[k]]} [[e']] }}

by

------------------- :: refl
e ~0> e

e0 ~> e1
e1 ~k> e2
------------------- :: step
e0 ~S k> e2



defns
JBig :: '' ::=

defn
e => v ::   :: big :: 'bs_'
{{ com big-step semantics }}
by


-------- :: val
v => v

e1 => v1
e2 [ v1 / x ] => v2
-----------------------   :: let
let x = e1 in e2 => v2


e1 => \x.e1'
e2 => v1
e1' [ v1 / x] => v2
--------------------  :: app
e1 e2 => v2

e => k
--------------------- :: succ
succ e => succ k

e => k
nrec_k of { 0 => e0 ; S x => e1 } => v
--------------------------------------------- :: nrec
nrec e of { 0 => e0 ; S x => e1 } => v


defn 
nrec_ k of { 0 => e0 ; S x => e1 } => v ::   :: big_nrec :: 'bsn_'
by 

e0 => v
------------------------------------------------ :: nrec_zero
nrec_ 0 of {0 => e0 ; S x => e1 }  => v

e1 [k / x] => \y. e' 
nrec_ k of { 0 => e0 ; S x => e1 } => v1
e' [ v1 / y] => v
--------------------------------------------- :: nrec_succ
nrec_ (S k) of {0=> e0 ; S x => e1 } => v

defns
JBigEnv :: '' ::=

defn
< rho | e > => w ::   :: big_env :: 'es_' 
{{ com environmental big-step semantics }}
by


---------------------- :: var
< rho | x > => rho x


------------------ :: lit
< rho | k > => k

------------------------------- :: abs
< rho | \x.e > => < rho , \x.e >


< rho | e1 > => v1
< v1/x,rho | e2> => v2
-----------------------   :: let
<rho | let x = e1 in e2 > => v2


<rho | e1 > => < rho' , \x.e1' >
<rho | e2 > => v1
<v1/x,rho' | e1'> => v2
--------------------  :: app
<rho | e1 e2 > => v2

<rho | e> => k
-------------------------- :: succ
<rho | succ e> => succ k


<rho | e> => k
<rho | nrec_ k of {0 => e0 ; S x => e1 }> => v
------------------------------------------------------ :: nrec
<rho | nrec e of { 0 => e0 ; S x => e1 }> => v


defn 
< rho | nrec_ k of { 0 => e0 ; S x => e1 } > => v ::   :: big_env_nrec :: 'big_env_nrec_'
by 


<rho | e1 > => v
---------------------------------------------------- :: nrec_zero
<rho | nrec_ 0 of { 0=> e0 ; S x => e1 }> => v

<rho | nrec_ k of { 0 => e0 ; S x => e1}> => v1
< k/x, rho | e1 > =>  < rho' , \y.e' >
< v1/y, rho' | e > => v2
------------------------------------------------------------------ :: nrec_succ
<rho | nrec_ (S k) of { 0=> e0 ; S x => e1 }> => v2
