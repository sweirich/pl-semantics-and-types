\chapter{Type and Effect systems}

The \rec\ language introduced the idea of a computational effect:
\emph{nontermination}.

However, this effect is invisible to the type system.  As a result, we had to
take a pessimistic view of well-typed \rec terms: any of them could diverge at
any time.

In this chapter, we will refine our type system so that its static analysis
can tell us more about a program than just the form of its resulting value (if
any). In particular, we will annotate our typing judgent with an effect
modality $[[eff]]$ that describes the potential \emph{effects} of computation
(if any). When tracking non-termination, the effect annotation can either be
$[[bot]]$ (indicating that we know the code terminates) or $[[top]]$,
indicating that it may diverge. However, the structure of the type-and-effect
system that we present is more general than that, and could be extended to
track other forms of effects.

\section{Core system}

For concreteness, we continue to work with fine-grained CBV \rec language,
reusing its syntax of terms and values and its small-step operational
semantics.  The key updates are all in the type system: we slightly modify the
syntax of types and we present a completely new pair of typing judgements for
values and computations.

This subsection starts with the design of the core system, ignoring (for now) 
features that introduce potential nontermination. In section~\ref{sec:recursion}
we extend this discussion to include recursive values and recursive types.
These rules are an example of a \emph{type-and-effect} system and
they are, in fact, general about the specific effects that are tracked by the
type system. We discuss what that means in section~\ref{sec:general-effects}.


\begin{definition}[Effect-annotated types]
\[
\begin{array}{llcl}
\mbox{effect flags} & [[eff]] &::=& [[bot]]\ |\ [[top]] \\
\\
\mbox{types} & [[tau]] &::=& [[Void]]\ |\ [[Nat]]\ |\ [[tau1 -> eff tau2]]
          |\ [[tau1 * eff tau2]]\ |\ [[tau1 + tau2]] \\
\end{array}
\]
\end{definition}

In this type-and-effect system, the type syntax includes effect annotations. 
These annotations $[[eff]]$ occur on the types of values
that can be recursive (i.e. function types and product types).  

Non-recursive products \textbf{can} use $[[bot]]$ for their annotation,
indicating projection has no effect. However \text{some} non-recursive
functions must use $[[top]]$ if they could diverge when applied, for example,
if their body contains an infinite loop. We say that the flags on this type
describe the \emph{latent} effect of the function: these effects happen not
when the function is created but could occur when the function is used.

\begin{definition}[\link{div/div.v}{typing}{Type system}]\ \\
\drules[tv]{$[[G ||- v : tau ]]$}{in context $[[G]]$, value $v$ has type $[[tau]]$}
{zero,succ,var,abs-eff,pair-eff,injOne,injTwo}
\drules[tee]{$[[G ||- e : tau @ eff]]$}{in context $[[G]]$, term $e$ has type $[[tau]]$ with effect $[[eff]]$}
{ret,let,app,ifz,prjOne,prjTwo,case,sub-eff}
\end{definition}

Values do not have effects, so we do not need to change their typing rules,
except for the introduction form for functions and products. 

In the effect annotated computation rules, the judgment form 
$[[G ||- e : tau @ eff]]$ uses $[[eff]]$ to indicate whether the computation $[[e]]$ is
pure (i.e. terminates) or may diverge.  Returned values must be pure, so
\rref{tee-ret} uses $[[bot]]$ for this annotation. However, a let binding
sequences the evaluation of two computations $[[e1]]$ and $[[e2]]$. Therefore,
the effect of the whole computation can be computed from the effect of these
two subterms, using the operation $[[eff1 + eff2]]$. For nontermination, this
computation returns $[[top]]$ if either effect is $[[top]]$ and $[[bot]]$ 
otherwise.

In the application rule, the effect of the computation is completely
determined by the latent effect of the function. If the function could diverge, for example if it is
$[[\x. loop]]$ or $[[\x. case x of { 0 => loop ; S y => y } ]]$,
then its type will include the $[[top]]$ effect.
On the other hand, if the function terminates on \emph{all} arguments, then 
the type uses the $[[bot]]$ effect.   
If the function is higher-order, i.e. if it takes another function as an argument, then the 
effect on the type of that argument determines the effect on the whole function. For example, 
we can give the function $[[\f. f (f 3)]]$ the type $[[ (Nat -> bot Nat) -> bot Nat ]]$ or 
the type $[[ (Nat -> top Nat) -> top Nat]]$. 

The two projections $[[prj1 v]]$ and $[[prj2 v]]$ use the effects from the product types. Because this 
language includes recursive values, it is possible for projection to cause divergence. For example, 
the computation 
\[ [[ prj1 (rec x . (x,x)) ]] [[~>]] [[prj1 (rec x. (x,x), rec x. (x,x))]] [[~>]] \ldots \]
does not terminate.

The two pattern-matching elimination forms require that the effects for both
branches be the same (just as the types of the both branches must be the
same). During type-checking time, if the scrutinee is a variable, we don't
know which branch will execute. So the effects of the computation could either
be the effects of the first branch or the effects of the second.

What if these two branches don't have the same effect, such as
$[[case x of { 0 => loop ; S y => y } ]]$ from above? In this case, we include
a \emph{subsumption rule},\rref{tee-sub-eff} which allows the type system to
weaken its analysis. Every effect system has a (pre)-order on effects. For
nontermination, we have $[[bot <: top]]$, meaning that if we know that a
system always terminates, then it is sound to weaken that analysis to say that
it might diverge.

With this subeffecting rule, this type system becomes our first example of a
system that is not syntax directed. In every other system that we have
encountered so far, we have had a 1-1 correspondence between typing rules and
syntax forms. This gives us strong inversion properties: If we have a
derivation, we know exactly what order the rules must be applied for the
system to type check.\footnote{Remember that even though a type system is
syntax-directed, it does not need to have unique types. All of our type
systems allow programs to be given multiple distinct types for some
functions.}

\section{Recursive values and types}
\label{sec:recursion}

The $[[top]]$ effect is explicitly introduced to the type system through the
typing rules for recursive values and types.  A recursively-defined function
or product \textbf{must} use $[[top]]$ in its type to indicate that it may
diverge.  This restriction is governed by the $[[tau ok]]$ judgement.

\begin{definition}
\drules[ok]{$[[tau ok]]$}{Values of type $[[tau]]$ can be recursive}
{fun-eff,prod-eff}
\end{definition}

\begin{definition}[\link{div/div.v}{typing}{Type system}]\ \\
\drules[tv]{$[[G ||- v : tau ]]$}{in context $[[G]]$, value $v$ has type $[[tau]]$}
{rec,fold}
\drules[tee]{$[[G ||- e : tau @ eff]]$}{in context $[[G]]$, term $e$ has type $[[tau]]$ with effect $[[eff]]$}
{unfold}
\end{definition}

Recall that the introduction rule for recursive values has a precondition that
states what types of values can be recursive. To make sure that the infinite
loops that these values can create is accurately accounted for, we require
function and product types to be marked with $[[top]]$ when they are assigned
to recursive definitions. This annotation is used when these values are
eliminated: the application and project rules need to know whether the value
could loop when it is in the active position.

Similarly, unfolding a value with a recursive type also triggers the $[[top]]$
effect. (We pessimistically assume that all values with recursive types could
cause nontermination, so there is no need to mark this in the recursive type
itself.)

\section{Syntactic metatheory: Preservation and progress}

Because this typing rules for computations are not syntax directed, we cannot
easily use inversion. If we have a derivation $[[G ||- e : tau @ eff]]$, the
\rref{sub-eff} rule could always have been used, so it is difficult to say
more about specific derivations. For example, the following lemma was
trivially true in the \rec type system. In this system, we must prove it by
induction.

\begin{lemma}[\link{rocq/div/div.v}{ret_inversion}{Ret inversion}]
If $[[ G ||- ret v : tau @ eff]]$ then $[[G ||- v : tau]]$.
\end{lemma}
\begin{proof}
We prove this by induction on the typing derivation. There are only two possible 
cases: \rref{tv-ret} and \rref{tv-sub}. In the first case, the result is immediate. 
In the second case, we must appeal to the induction hypothesis.
\end{proof}

In our type safety proof, the place where we commonly use inversion in in the
progress lemma: we need to know the form of a value given its type. Sometime
we explicitly state these inversions as canonical forms lemmas. In this setting, 
only the computation typing rule includes a non-syntax directed rule. In our 
value typing rule, there is exactly one rule for each syntactic form of value.


\section{Effect soundness}

To know whether the effect annotations in our type system are meaningful, we
need to prove more than type safety --- we need to argue that if a term has
type $[[ ||- e : tau @ bot ]]$ then it must terminate. As before, we can prove
this result using a logical relation.

As we are only concerned with terminating programs, we don't need to use a step 
indexed logical relation. Instead, we can take advantage of the simpler definition 
by structural recursion on the type structure. In the case of recursive types, 
we use the empty set because our type system does not allow values with recursive
types to be used in computations marked $[[bot]]$.

The key difference in this definition is that the computation set is also indexed 
by the effect. 
\[ 
\begin{array}{lcl} 
[[ C tau bot ]] &=& [[ { e | e ~>* v and v elem V tau } ]]   \\
[[ C tau top ]] &=& \textit{all terms}  \\
\\
\\
[[ V Void ]] &=& \emptyset \\
[[ V Nat ]] &=& [[nats]] \\
[[ V tau1 -> eff tau2 ]] &=& 
   \{\ v\ |\ \forall [[v1]],\ [[v1 elem V tau1]]\ \mathit{implies}\ [[ v v1 elem C tau2 eff]]\  \}  \\
[[ V tau1 * eff tau2 ]] &=&
   [[ { v | prj1 v elem C tau1 eff and prj2 v elem C tau2 eff } ]] \\
[[ V mu alpha.tau ]] &=& \{\ [[fold v]]\ |\ [[v elem vals]] \}   \\
\end{array}
\]

Note that the computation set is compatible with the effect ordering. This property is important to reason about our subeffecting rule. As this rule 
is not syntax directed, we need to make sure that the set for the larger effect contains all of the same terms.
\begin{lemma}[\link{rocq/eff/div.v}{C\_sub}{Subeffecting}]
If $[[eff1 <: eff2]]$ then $[[C tau eff1]] \subseteq [[C tau eff2]]$
\end{lemma}

As usual, we can prove the fundamental property of this logical relation by
validating each of the semantic typing rules. This lemma says that the
relation contains all well typed values and terms. (For brevity, we don't list those 
lemmas here.)

\begin{lemma}[\link{rocq/eff/div.v}{}{Fundamental lemma}]
If $[[G ||- e : tau @ eff ]]$ then $[[ G |= e : tau @ eff ]]$.
If $[[G ||- v : tau ]]$ then $[[ G |= v : tau ]]$.
\end{lemma}

Using the fundamental lemma above, and the definition of $[[C tau bot]]$, we
can show that the termination effect implies termination. 

\begin{lemma}[\link{rocq/eff/eff.v}{}{Effect soundness}]
If $[[ ||- e : tau @ bot ]]$, then there exists some v, such that $[[ e ~>* v ]]$.
\end{lemma}

Note that our definition of $[[C tau top]]$ does not tell us \emph{anything}
about terms with the $[[top]]$ effect. We could strengthen this result, by
combining it with the step-indexed semantic soundness property of the previous
chapter. But, observe that we are able to prove termination for the $[[bot]]$ 
fragment without doing so.

\section{Generalizing effects}
\label{sec:general-effects}

This type system is specialized to tracking non-termination. However, if we
view these rules more abstractly if we consider effects to be an abstract
structure.

Looking at the rules, we need the following operations from our abstract
structure:

\begin{tabular}{ll}
$[[eff]]$ & some type of effect annotation \\
$[[bot]]$ & annotation for ``pure'' code \\
$[[eff1 + eff2]]$ & combination of effects \\
$[[eff1 <: eff2]]$ & ordering of effects \\
\end{tabular}

It will turn out, that to show that our type-and-effect system has the rules that we want, we will also want to assume some properties about this structure. 
In particular, we will want to make sure that this structure is a \emph{pre-ordered monoid}.

Our structure is a monoid if it satisfies the following three properties:
\begin{enumerate}
\item Left identity: $[[bot + eff = eff]]$
\item Right identity: $[[eff + bot = eff]]$
\item Associativity: $[[(eff1 + eff2) + eff3 = eff1 + (eff2 + eff3)]]$
\end{enumerate}

It is a preorder if $[[<:]]$ is reflexive and transitive. In other words, if we have $[[eff <: eff]]$ and $[[eff1 <: eff2]]$ and $[[eff2 <: eff3]]$ implies $[[eff1 <: eff3]]$.

Finally, it is a preordered monoid if the ordering is compatible with the combining operation. In other words, we have
$[[ eff1 <: eff1']]$ and $[[eff2 <: eff2']]$ then $[[eff1 + eff2 <: eff1' + eff2']]$.

It turns out that the specific structure that we use here, with the definition 
of $[[eff]]$ as $[[bot]]$ or $[[top]]$, the ordering $[[bot <: top]]$ and the 
combining operation described above, satisfies these properties. This structure
satisfies other properties as well, such as commutativity of $[[eff1 + eff2]]$, 
but we will find that we won't need to use that property in our proofs.

To modify this type system to track other forms of effects, we need to modify
the effect structure that we use accordingly. 

\section{Expressivity}

The type system shown in this chapter is designed to show the essence of how type-and-effect systems can work. As a result, it is rather simplistic and not expressive enough for practical programmer. 

\emph{Strengthening the termination analysis: recursive definitions} The type
system that we have defined does not include a very large fragment that can be
checked with effect $[[bot]]$. The reason is the innate pessimism of general
recursion. There is no way to conclude that a recursive definition actually
terminates. 

One way to make the language more expressive is to include more capabilities
for terminating recursive definitions. For example, we could add the primitive
natural number recursion operation from Chapter~\ref{chapter:nrec}. Type
systems that enforce termination (such as the type theories of Rocq, Agda or
Lean, include many such recursion principles for inductive datatypes.

\paragraph{Subtype polymorphism} Many languages with effect systems also support subtype polymorphism. 
What this means in this context is the addition of two new rules that allow
the type of a value or term to be replaced by any of its supertypes.

\[ \drule{tv-sub} \qquad \drule{tee-sub-eff-ty} \]

In essence, the subsumption rules weaken what we know: for example, we may forget that 
a function will always terminate when applied.

The subtyping relation is induced by the effect annotations function and
product types. For example, a function annotated by $[[bot]]$ must always terminate, whereas
a function annotated by $[[top]]$ may terminate or may diverge. Similarly, projection from 
a tuple annotated by $[[bot]]$ will always terminate, but from a tuple annotated by $[[top]]$ 
could diverge. 

\begin{definition}[Subtyping]\ \\
\drules[s]{$[[tau1 <: tau2 ]]$}{$[[tau1]]$ is a subtype of $[[tau2]]$}
{refl,arr,prod,sum}
\end{definition}

On top of this relationship, the rules for subtyping above extend the
primitive subtyping relationship compatibly through the structure of
types. Following standard practice, subtyping is \emph{covariant} (i.e. in the
same direction) in the components of pairs and sums and the result type of
functions. It is \emph{contravariant} in the argument of functions.

For example, we can show the following relationship between these two types
\[ [[ (tau1 -> top tau2) -> bot (tau1 -> bot tau2) ]] <: [[ (tau1 -> bot tau2) -> bot (tau1 -> top tau2) ]] \]
(Both of these types can be assigned to the higher-order function $[[\x.ret (\y.x y)]]$).

\paragraph{Effect polymorphism} 

Although terms of this type system do not include any type or effect
annotations, type \emph{inference} for this type system should be
decidable.\footnote{This is a conjecture, we don't have a proof yet.}

However, although an inference algorithm exists, it is not a
\emph{compositional} algorithm. We cannot break a program into parts and 
type check each part individually; we need to know how definitions are  
used to figure out what type their types should be.

Most efficient type inference systems are based on the idea of \emph{principal
types}. This means that for any term in a given context, we can assign a
unique ``best'' type for that term, i.e., one that can be used in any typing
derivation featuring that term.

Principal typing fails for this language. To see why, note that 
we can give the term $[[\x.ret (\y.x y)]]$ \emph{many} different types of the form:
$[[ (tau1 -> eff1 tau2) -> eff1 (tau1 -> eff3 tau2) ]]$.

There are eight possible combinations of these annotations, and six of them are 
valid types for the term.  (Options (5) and (7) do not type check. Only configurations 
where $[[eff1 <: eff3]]$ are allowed.)
\[
\begin{array}{rcccl}
    &[[eff1]] & [[eff2]] & [[eff3]] \\
\hline
(1) &[[bot]] & [[bot]] & [[bot]] \\
(2) &[[bot]] &[[bot]] &[[top]] \\
(3) &[[bot]] &[[top]] &[[bot]] \\
(4) &[[bot]] &[[top]] &[[top]] \\
\textit{Doesn't type check}\ (5) &[[top]] &[[bot]] &[[bot]] \\
(6) &[[top]] &[[bot]] &[[top]] \\
\textit{Doesn't type check}\ (7) &[[top]] &[[top]] &[[bot]] \\
(8) &[[top]] &[[top]] &[[top]] \\
\end{array}
\]

If we look at the subtyping relationships between these types, we can arrange them into the following hierarchy, where subtypes are to the left and super types are to the rigfht.
\begin{verbatim}
           (2) 
    (6) <:     <:
           (8)    (4)
    (1) <:     <:
           (3) 
\end{verbatim}
Type (4), i.e., $[[ (tau1 -> bot tau2) -> top (tau1 -> top tau2) ]]$ is the maximum type---all other valid types are a subtype of this type.  However, there is no \emph{minimum} type. 
Both types (1) and (6) are subtypes of the rest of the types, but they are not comparable to eachother. 

The reason is that both of these types are instances of a more general pattern:
\[ [[ (tau1 -> bot tau2) -> bot (tau1 -> bot tau2) ]] \qquad \mbox{and} \qquad [[ (tau1 -> top tau2) -> bot (tau1 -> top tau2) ]] \]
The effect of the output function ($[[eff3]]$) depends on the effect of the input function $([[eff1]]$). We can capture this relationship using \emph{effect polymorphism}, which would 
allow us to assign the following type to the function.

\[ [[ forall epsilon. (tau1 -> epsilon tau2) -> bot (tau1 -> epsilon tau2) ]] \] 

Note that effect polymorphism is not the only reason that this type system lacks principal types. To really develop a compositional system, we also need to include \emph{type polymorphism}, as is found in ML or Haskell. Therefore, the best type of the term can be defined as:

\[ [[ forall alpha1. forall alpha2. forall epsilon. (alpha1 -> epsilon alpha2) -> bot (alpha1 -> epsilon alpha2) ]] \] 

At the same time, the more that we add to the language, the more difficult
type inference becomes. When we add effect and type polymorphism, we need to
extends any hypothetical type inference algorithm to include those
features. The former, especially with this minimal (two point) effect
structure is not difficult to accommodate. However, for the latter, we must be
careful and stick to restrictions such as \emph{prenex
polymorphism}~\cite{milner:polymorphism} that are known to be well-behaved, if
we would like to infer all types.

\paragraph{Value-dependent or path-dependent effects} 
The type-and-effect analysis approximates runtime behavior when it comes to branching. 
The rule for case analysis \rref{tee-ifz} requires that after testing a natural number, 
both branches produce the same type of value and have the same effect. This rule is designed this way because static type checking does not evaluate programs, but instead must explore all paths. 

However, there may be some relationship between the value of natural number
and the effects of each branch. A dependent type system, can express how the
effect of a conditional may be determined by this value.


\section{Variation: Syntax-directed effects}

The subsumption rule makes the type-and-effect system not syntax
directed. However, we can reformulate the system so that this rule is not
necessary. Instead, subeffecting is worked into the other rules.

\begin{definition}[\link{div/sd.v}{typing}{Syntax-directed Type system}]\ \\
\drules[sd-tee]{$[[G !- e : tau @ eff]]$}{in context $[[G]]$, term $e$ has type $[[tau]]$ with effect $[[eff]]$}
{let,app,prjOne,prjTwo}
\end{definition}

By looking at the rules, we can see that sub-effecting is an \emph{admissible} rule for 
the system. Even though we don't have a specific rule, we can always turn a derivation into 
another with a larger effect.
\begin{lemma}[Subeffecting for syntax-directed system]
If $[[G !- e : tau @ eff1 ]]$ and $[[eff1 <: eff2]]$ then $[[G !- e : tau2 @ eff2]]$.
\end{lemma}

Using the subeffecting property, we can show that this type system is equivalent to our previous 
version. We state the property as follows.

\begin{lemma}[\link{div/sd.v}{Equivalence}{Equivalence between syntax-directed and core system}]\ \\
\begin{enumerate}
\item $[[G ||- e : tau @ eff ]]$ iff $[[G !- e : tau @ eff ]]$.
\item $[[G ||- v : tau ]]$ iff $[[G !- v : tau ]]$.
\end{enumerate}
\end{lemma}

When thinking about syntax-directed judgements, it is useful to assign \emph{modes} to the 
components of the judgement. These modes correspond to whether that component is an 
input or an output to a function that determines whether the judgement is derivable.
In this case, we have designed the type system as if the effect is an input to the judgement: i.e. it should be larger the actual effect of the term.

\section{Historical notes and further reading}

Type-and-effect systems~\cite{gifford:effects86,lucassen:effects88} were
originally developed to track memory usage.
